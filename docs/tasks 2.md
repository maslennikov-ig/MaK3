> **Продолжение:** Это часть 2 из 3 большого файла задач. Начало смотри в [tasks.md](./tasks.md), следующая часть — [tasks 3.md](./tasks%203.md).

---

## Внутренние документы проекта

- [architecture.md — Архитектура](./architecture.md)
- [infrastructure.md — Инфраструктура](./infrastructure.md)
- [project-structure.md — Структура проекта](./project-structure.md)
- [roadmap.md — Дорожная карта](./roadmap.md)
- [changelog.md — Журнал изменений](./changelog.md)
- [questions-to-tz.md — Вопросы к ТЗ](./questions-to-tz.md)
- [ТЗ_CRM_2025.md — Основное ТЗ](./ТЗ_CRM_2025.md)

---

## **Правила работы с задачами (дополненные)**
use context7

* Всегда сначала ищем готовую, поддерживаемую библиотеку или компонент, а не пишем с нуля.
* Предпочитаем использовать самые новые, но стабильные версии библиотек, компонентов и модулей.
* Если возникает проблема с зависимостями, и нет возможности обновить до последних стабильных версий — отказываемся от проблемного модуля и ищем современную альтернативу, а не фиксируем старую зависимость.

* Всегда предлагайте архитектурные улучшения или альтернативные варианты, если это может повысить модульность, читаемость или масштабируемость системы.
* Используйте современные best practices для выбранных технологий (например, Server Components в Next.js, feature/domain-based структура, паттерны NestJS/Prisma).
* При необходимости обращайтесь к официальной документации и используйте Context7 для поиска актуальных решений, ссылайтесь на источники.
* Для задач по безопасности явно указывайте потенциальные риски и способы их минимизации (особенно для аутентификации/авторизации, работы с данными, интеграций).

* Отмечайте выполненные задачи как \[x\]  
* Запрашивайте одобрение пользователя перед началом следующей фазы.  
* Указывайте измененные файлы рядом с задачей (в комментарии или подпункте).  
* Не отмечайте будущие задачи как выполненные, пока не получите явного запроса.  
* Задачи сгруппированы по фазам разработки. Следуйте порядку.  
* Используйте единообразное именование и структуру при добавлении новых задач.  
* При необходимости добавляйте ссылки на документацию или ресурсы.  
* Если задача заблокирована, четко укажите причину и зависимости.  
* Проверяйте завершенные фазы на полноту перед переходом к следующей.  
* По желанию добавляйте временные метки для отслеживания прогресса.  
* Используйте встроенные комментарии для примечаний или обоснования изменений.  
* **Контекст и Цель:** Каждая задача должна начинаться с краткого описания цели (Что мы хотим достичь?) и контекста (Какая часть системы затрагивается? Какие есть зависимости?).  
* **Ожидаемый Результат (Acceptance Criteria):** Четко определить, что считается успешным выполнением задачи (например, "сгенерирован код модуля X с покрытием тестами Y%", "создана схема БД для Z", "настроен CI/CD пайплайн, который выполняет A, B, C").  
* **Технологические Указания:** Указывать конкретные технологии, библиотеки, версии (если критично), паттерны проектирования, которые ИИ должен использовать.  
* **Примеры (если применимо):** Предоставлять небольшие примеры кода, структуры данных или ожидаемого вывода.  
* **Нефункциональные Требования:** Упоминать релевантные нефункциональные требования (производительность, безопасность, читаемость кода, логирование) для конкретной задачи.  
* **Итеративность:** Для сложных задач предлагать ИИ разбить их на подзадачи или генерировать решение по частям, запрашивая обратную связь.  
* **Формат Вывода:** Указывать желаемый формат вывода (например, "предоставить код в виде файла .ts", "сгенерировать Prisma schema", "предоставить команду для Docker CLI").  
* **Вопросы для Уточнения:** Поощрять ИИ задавать уточняющие вопросы, если задача недостаточно ясна.  
* **Фокус на Безопасности:** Для задач, связанных с данными или аутентификацией, явно указывать на необходимость учета аспектов безопасности (например, "реализовать с учетом защиты от XSS", "использовать параметризованные запросы").  
* **Документирование Кода:** Требовать генерации комментариев к коду (TSDoc/JSDoc) для всех публичных функций и сложной логики.  
* **Генерация Тестов:** Для большинства задач по генерации кода требовать также генерации соответствующих юнит-тестов.  
* **Указание на Файлы:** Просить ИИ указывать, какие файлы были созданы или модифицированы.

## **Этап 2: Ключевые Интеграции и Единый Кабинет для Внешних Пользователей (MVP Часть 2\) (8-10 недель)**

**Цель этапа:** Интегрировать систему с AmoCRM, разработать Telegram-бота и создать основу Единого Кабинета для Партнёров и Франчайзи, обеспечив безопасный и ролевой доступ к данным.

### **Спринт 6-7: Интеграция с AmoCRM (3-4 недели)**

**Цель спринтов:** Реализовать надежную двустороннюю синхронизацию данных (клиенты, сделки, статусы) с AmoCRM, используя асинхронные задачи для обработки и предоставляя администратору интерфейс для управления интеграцией.

#### **Backend (NestJS)**

* \[ \] **Задача 2.1.1: Глубокий анализ API AmoCRM и определение сценариев интеграции.**  
  * **Контекст:** Необходимо детально изучить документацию API AmoCRM (последнюю версию) для понимания методов аутентификации (OAuth 2.0), доступных сущностей (контакты, компании, сделки, воронки, статусы, задачи, кастомные поля), лимитов API, вебхуков и механизма обработки ошибок. Это основа для проектирования модуля интеграции. Сценарии интеграции должны соответствовать ТЗ 2.6.  
  * **Тех. указания:**  
    1. \[ \] ИИ должен найти официальную документацию AmoCRM API (developer.amocrm.ru или аналогичный).  
    2. \[ \] Проанализировать методы аутентификации и выбрать наиболее подходящий (OAuth 2.0 Authorization Code Grant).  
    3. \[ \] Определить эндпоинты для получения, создания, обновления контактов, компаний (если используются), сделок, статусов сделок.  
    4. \[ \] Исследовать возможность использования вебхуков AmoCRM для получения обновлений в реальном времени или близком к нему.  
    5. \[ \] Составить список полей для маппинга между MaK CRM (сущности Contact, Deal, PipelineStage из schema.prisma) и AmoCRM. Обратить внимание на кастомные поля в AmoCRM.  
    6. \[ \] Описать сценарии двусторонней синхронизации:  
       * \[ \] Создание/обновление контакта в MaK CRM \-\> Создание/обновление в AmoCRM.  
       * \[ \] Создание/обновление сделки в MaK CRM \-\> Создание/обновление в AmoCRM.  
       * \[ \] Изменение статуса сделки в MaK CRM \-\> Изменение статуса в AmoCRM.  
       * \[ \] Создание/обновление контакта/сделки в AmoCRM (через вебхук или периодический опрос) \-\> Создание/обновление в MaK CRM.  
  * **Ожидаемый результат:**  
    * Ссылки на ключевые разделы документации AmoCRM API.  
    * Краткий документ (Markdown) с описанием:  
      * Выбранного метода аутентификации и его потока.  
      * Таблицы маппинга полей (MaK CRM \<-\> AmoCRM) для Контактов и Сделок, включая статусы.  
      * Детального описания логики синхронизации для каждого сценария (триггеры, направление данных, обработка конфликтов – базовая стратегия, например, "последнее изменение побеждает" или приоритет одной из систем).  
      * Предложения по обработке лимитов API AmoCRM (например, использование очередей с задержками).  
* \[ \] **Задача 2.1.2: Разработка модуля интеграции с AmoCRM (AmoCRMModule).**  
  * **Контекст:** Создание сервиса в NestJS для инкапсуляции всей логики взаимодействия с API AmoCRM.  
  * **Тех. указания:**  
    1. \[ \] Создать модуль AmoCRMModule (backend/src/amocrm/amocrm.module.ts).  
    2. \[ \] Создать сервис AmoCRMService (backend/src/amocrm/amocrm.service.ts).  
    3. \[ \] Реализовать в AmoCRMService методы для OAuth 2.0 аутентификации:  
       * \[ \] Получение URL для редиректа пользователя на страницу авторизации AmoCRM.  
       * \[ \] Обработка callback от AmoCRM с кодом авторизации.  
       * \[ \] Обмен кода авторизации на access\_token и refresh\_token.  
       * \[ \] Безопасное хранение токенов (например, в БД, ассоциированные с настройками интеграции, шифрование токенов).  
       * \[ \] Автоматическое обновление access\_token с использованием refresh\_token.  
    4. \[ \] Реализовать методы-обертки для API AmoCRM (использовать axios или @nestjs/axios):  
       * \[ \] getContact(amocrmContactId)  
       * \[ \] createContact(contactData)  
       * \[ \] updateContact(amocrmContactId, contactData)  
       * \[ \] getDeal(amocrmDealId)  
       * \[ \] createDeal(dealData)  
       * \[ \] updateDeal(amocrmDealId, dealData)  
       * \[ \] getPipelineStages(pipelineId)  
    5. \[ \] Реализовать маппинг данных (из Задачи 2.1.1) внутри этих методов или в отдельных helper-функциях.  
    6. \[ \] Реализовать обработку ошибок API AmoCRM (коды ответа, структура ошибок) и логирование запросов/ответов (можно использовать стандартный Logger NestJS или Sentry).  
    7. \[ \] Использовать @nestjs/config для получения URL API AmoCRM, client\_id, client\_secret.  
  * **Ожидаемый результат:**  
    * Код для AmoCRMModule и AmoCRMService.  
    * DTO для данных AmoCRM (если необходимо).  
    * Юнит-тесты для AmoCRMService (с мокированием HTTP запросов).  
  * *Файлы: backend/src/amocrm/\*\* (новая папка с модулем), обновления в backend/src/config/\*\* для конфигурации AmoCRM.*  
* \[ \] **Задача 2.1.3: Реализация логики синхронизации и использование BullMQ.**  
  * **Контекст:** Обеспечение асинхронной и надежной двусторонней синхронизации данных. Задачи будут ставиться в очередь BullMQ (настроенную в Этапе 3), а обработчики будут вызывать AmoCRMService.  
  * **Тех. указания:**  
    1. \[ \] Определить задачи для BullMQ (очередь amoCRMSyncQueue):  
       * \[ \] syncContactToAmo: payload { makContactId: string }  
       * \[ \] syncDealToAmo: payload { makDealId: string }  
       * \[ \] syncContactFromAmo: payload { amocrmContactId: string, amocrmContactData: any } (если через вебхук)  
       * \[ \] syncDealFromAmo: payload { amocrmDealId: string, amocrmDealData: any } (если через вебхук)  
    2. \[ \] **Продюсеры задач:**  
       * \[ \] В ContactsService и DealsService (MaK CRM), после создания/обновления контакта/сделки, ставить задачи syncContactToAmo / syncDealToAmo в очередь amoCRMSyncQueue.  
    3. \[ \] **Обработчики задач (Processors):**  
       * \[ \] Создать AmoCRMSyncProcessor (backend/src/jobs/processors/amocrm-sync.processor.ts).  
       * \[ \] Реализовать обработчики для каждой задачи:  
         * \[ \] @Process('syncContactToAmo'): получить данные контакта из MaK CRM, вызвать AmoCRMService.createContact/updateContact. Сохранить amocrmContactId в MaK CRM.  
         * \[ \] @Process('syncDealToAmo'): аналогично для сделок.  
         * \[ \] @Process('syncContactFromAmo'): получить данные из AmoCRM (передаются в payload или запросить по ID), найти/создать/обновить контакт в MaK CRM. Сохранить amocrmContactId.  
         * \[ \] @Process('syncDealFromAmo'): аналогично для сделок.  
       * \[ \] Реализовать базовую логику предотвращения зацикливания синхронизации (например, проверять источник последнего изменения или временные метки).  
    4. \[ \] **Вебхуки (если используются):**  
       * \[ \] Создать контроллер в NestJS (WebhookController) с эндпоинтом для приема вебхуков от AmoCRM.  
       * \[ \] Эндпоинт должен валидировать запрос от AmoCRM (если есть механизм подписи) и ставить задачи syncContactFromAmo / syncDealFromAmo в очередь.  
    5. \[ \] **Периодический опрос (если вебхуки не используются или для подстраховки):**  
       * \[ \] Создать задачу для cron (например, с @nestjs/schedule или отдельный job BullMQ), которая периодически запрашивает последние изменения из AmoCRM и ставит задачи на синхронизацию.  
  * **Ожидаемый результат:**  
    * Обновленные ContactsService, DealsService с постановкой задач в очередь.  
    * Код для AmoCRMSyncProcessor.  
    * Код для WebhookController (если используется).  
    * Код для периодической задачи опроса (если используется).  
  * *Файлы: backend/src/contacts/contacts.service.ts, backend/src/deals/deals.service.ts, backend/src/jobs/processors/amocrm-sync.processor.ts (новый), backend/src/webhooks/webhooks.controller.ts (новый, если нужно), backend/src/scheduler/scheduler.service.ts (новый, если нужно).*

#### **Frontend (Next.js)**

* \[ \] **Задача 2.2.1: Интерфейс для настройки и управления интеграцией с AmoCRM администратором.**  
  * **Контекст:** Предоставление UI для администратора для подключения и управления интеграцией с AmoCRM.  
  * **Тех. указания:**  
    1. \[ \] Создать страницу /admin/integrations/amocrm (frontend/src/app/admin/integrations/amocrm/page.tsx).  
    2. \[ \] Компоненты Mantine для UI.  
    3. \[ \] **Состояние подключения:** Отображать текущий статус (Не подключено / Подключено как ИМЯ\_АККАУНТА\_AMOCRM).  
    4. \[ \] **Подключение:**  
       * \[ \] Если не подключено: кнопка "Подключить AmoCRM". При нажатии редирект на URL авторизации AmoCRM (полученный с бэкенда).  
       * \[ \] Бэкенд должен предоставить API (GET /amocrm/auth-url) для получения этого URL.  
       * \[ \] Бэкенд должен иметь callback URL (/amocrm/oauth-callback), который AmoCRM вызовет после авторизации. Этот callback должен сохранить токены и, возможно, редиректнуть обратно на страницу настроек с параметром успеха/ошибки.  
    5. \[ \] **Настройки (если подключено):**  
       * \[ \] Возможность выбора воронок для синхронизации (если требуется).  
       * \[ \] Маппинг статусов (если не жестко задан).  
       * \[ \] Кнопка "Отключить AmoCRM" (удаляет токены и деактивирует интеграцию на бэкенде).  
    6. \[ \] Все действия должны вызывать соответствующие API на бэкенде (например, POST /amocrm/disconnect, POST /amocrm/settings).  
  * **Ожидаемый результат:**  
    * Страница настроек интеграции с AmoCRM.  
    * API на бэкенде для управления подключением и настройками.  
  * *Файлы: frontend/src/app/admin/integrations/amocrm/page.tsx (новый), backend/src/amocrm/amocrm.controller.ts (новые эндпоинты).*  
* \[ \] **Задача 2.2.2: Отображение статуса синхронизации и логов (базово).**  
  * **Контекст:** Информирование администратора о работе интеграции.  
  * **Тех. указания:**  
    1. \[ \] На странице /admin/integrations/amocrm:  
       * \[ \] Отображать время последней успешной синхронизации (в обе стороны, если отслеживается).  
       * \[ \] Количество синхронизированных записей за последний период (например, за последние 24 часа).  
       * \[ \] Список последних 5-10 ошибок синхронизации (если есть).  
    2. \[ \] Бэкенд должен предоставлять API для получения этой информации (например, GET /amocrm/sync-status). Данные можно брать из логов или специальной таблицы аудита синхронизаций.  
  * **Ожидаемый результат:**  
    * Обновленная страница настроек с информацией о статусе синхронизации.  
    * API на бэкенде для получения статуса.  
  * *Файлы: frontend/src/app/admin/integrations/amocrm/page.tsx (обновление), backend/src/amocrm/amocrm.controller.ts (новый эндпоинт).*

### **Спринт 8: Telegram-бот (2-3 недели)**

**Цель спринта:** Создать Telegram-бота для уведомлений о ключевых событиях в CRM и предоставления пользователям базовой информации и действий через Telegram.

#### **Backend (NestJS)**

* \[ \] **Задача 2.3.1: Разработка Telegram-бота с использованием telegraf.**  
  * **Контекст:** Создание основы для Telegram-бота, включая его инициализацию и базовые команды.  
  * **Тех. указания:**  
    1. \[ \] Установить telegraf: npm install telegraf.  
    2. \[ \] Создать TelegramModule (backend/src/telegram/telegram.module.ts).  
    3. \[ \] Создать TelegramService (backend/src/telegram/telegram.service.ts):  
       * \[ \] Инициализировать экземпляр Telegraf с токеном бота (из @nestjs/config).  
       * \[ \] Реализовать метод для запуска бота (bot.launch()).  
       * \[ \] Зарегистрировать обработчики для команд:  
         * \[ \] /start: приветственное сообщение, информация о боте, предложение связать аккаунт MaK CRM.  
         * \[ \] /help: список доступных команд.  
         * \[ \] /link \<code\>: команда для связывания аккаунта (см. Задачу 2.3.3).  
    4. \[ \] Обеспечить graceful shutdown бота при остановке NestJS приложения.  
  * **Ожидаемый результат:**  
    * Код для TelegramModule и TelegramService.  
    * Бот отвечает на команды /start и /help.  
  * *Файлы: backend/src/telegram/\*\* (новая папка с модулем).*  
* \[ \] **Задача 2.3.2: Реализация уведомлений и просмотра информации.**  
  * **Контекст:** Основной функционал бота по информированию и предоставлению данных согласно ТЗ 2.6.  
  * **Тех. указания:**  
    1. \[ \] **Уведомления:**  
       * \[ \] В TelegramService создать метод sendNotification(telegramChatId: string, message: string).  
       * \[ \] Использовать систему событий NestJS (@nestjs/event-emitter):  
         * \[ \] Определить события, например, NewContactEvent, NewDealEvent, DealStatusChangedEvent.  
         * \[ \] В ContactsService и DealsService генерировать эти события при соответствующих действиях.  
         * \[ \] Создать слушателя событий (@OnEvent(...)) в TelegramModule или TelegramService, который будет получать событие, определять заинтересованных пользователей (у которых связан Telegram и включены уведомления для данного типа события) и вызывать sendNotification.  
         * \[ \] Формат сообщений должен быть информативным и включать ссылки на сущности в MaK CRM (если возможно).  
    2. \[ \] **Просмотр информации (для связанных пользователей):**  
       * \[ \] Команда /mycontacts: отображает список последних 5 контактов пользователя (ФИО, телефон). Кнопки "Следующие" / "Предыдущие" для пагинации.  
       * \[ \] Команда /mydeals: аналогично для сделок (Название, Сумма, Этап).  
       * \[ \] Команда /viewcontact \<MaK\_CRM\_Contact\_ID\> (или выбор из списка): отображает детальную информацию о контакте.  
       * \[ \] Команда /viewdeal \<MaK\_CRM\_Deal\_ID\>: аналогично для сделки.  
       * \[ \] TelegramService должен запрашивать данные у ContactsService / DealsService, учитывая права текущего пользователя (определенного по telegramChatId).  
  * **Ожидаемый результат:**  
    * Реализованы уведомления о новых клиентах/сделках.  
    * Реализованы команды для просмотра информации.  
  * *Файлы: backend/src/telegram/telegram.service.ts (обновление), backend/src/contacts/contacts.service.ts (генерация событий), backend/src/deals/deals.service.ts (генерация событий), backend/src/events/\*\* (новые классы событий).*  
* \[ \] **Задача 2.3.3: Интеграция с системой аутентификации MaK CRM.**  
  * **Контекст:** Безопасное связывание аккаунта Telegram с аккаунтом MaK CRM для персонализированного доступа к данным.  
  * **Тех. указания:**  
    1. \[ \] **Генерация кода связывания в MaK CRM:**  
       * \[ \] В UserService или AuthService (MaK CRM) создать метод для генерации уникального, короткоживущего кода связывания для пользователя. Сохранять этот код в БД (User entity, поле telegramLinkCode, telegramLinkCodeExpiresAt).  
       * \[ \] На бэкенде создать API эндпоинт (POST /users/me/generate-telegram-link-code), который генерирует и возвращает этот код пользователю.  
    2. \[ \] **Обработка команды /link \<code\> в боте:**  
       * \[ \] TelegramService получает код от пользователя.  
       * \[ \] Вызывает API эндпоинт на бэкенде MaK CRM (POST /telegram/link-account, payload: { code: string, telegramChatId: string, telegramUserId: number, telegramUsername?: string }).  
       * \[ \] Бэкенд API проверяет код, его срок действия. Если код валиден, сохраняет telegramChatId, telegramUserId, telegramUsername в сущности User MaK CRM и удаляет/аннулирует telegramLinkCode.  
    3. \[ \] При обработке команд, требующих аутентификации, TelegramService использует telegramChatId для идентификации пользователя в MaK CRM (запрос к UserService по telegramChatId).  
  * **Ожидаемый результат:**  
    * Механизм связывания аккаунтов работает.  
    * API на бэкенде для генерации кода и связывания аккаунта.  
    * Обновленная Prisma schema для User (добавить telegramChatId, telegramUserId, telegramUsername, telegramLinkCode, telegramLinkCodeExpiresAt).  
  * *Файлы: backend/src/users/user.service.ts (обновление), backend/src/users/user.controller.ts (новый эндпоинт), backend/src/telegram/telegram.service.ts (обновление), backend/src/telegram/telegram.controller.ts (новый эндпоинт для /telegram/link-account), backend/prisma/schema.prisma (обновление).*

#### **Frontend (Next.js)**

* \[ \] **Задача 2.4.1: Интерфейс для управления настройками Telegram-бота и связывания аккаунта.**  
  * **Контекст:** Предоставление UI пользователям MaK CRM для управления связью с Telegram-ботом.  
  * **Тех. указания:**  
    1. \[ \] **Страница настроек для Администратора (/admin/integrations/telegram):**  
       * \[ \] Отображение статуса бота (активен/неактивен \- можно пинговать бота или проверять last seen).  
       * \[ \] Возможно, статистика по связанным пользователям.  
    2. \[ \] **Раздел в профиле пользователя (/profile/integrations или /profile/telegram):**  
       * \[ \] Отображение текущего статуса связывания (Связан как @username / Не связан).  
       * \[ \] Кнопка "Связать с Telegram": при нажатии вызывает API (POST /users/me/generate-telegram-link-code) для получения кода. Отображает код пользователю с инструкцией отправить его боту (/link \<code\>).  
       * \[ \] Кнопка "Отвязать от Telegram" (если связан): вызывает API на бэкенде для удаления telegramChatId из профиля пользователя.  
       * \[ \] Настройки уведомлений (чекбоксы): "Уведомлять о новых клиентах", "Уведомлять о новых сделках" (сохранение настроек на бэкенде в профиле пользователя).  
  * **Ожидаемый результат:**  
    * UI для администратора для базового мониторинга.  
    * UI в профиле пользователя для связывания/отвязывания и настройки уведомлений.  
    * Соответствующие API на бэкенде для управления настройками уведомлений пользователя.  
  * *Файлы: frontend/src/app/admin/integrations/telegram/page.tsx (обновление или новый), frontend/src/app/profile/integrations/page.tsx (новый), backend/src/users/user.controller.ts (новые эндпоинты для настроек уведомлений).*

### **Спринт 9-10: Единый Кабинет для Внешних Пользователей (Партнёры/Франчайзи) (основа) (3-4 недели)**

**Цель спринтов:** Создать базовую, но функциональную версию Единого Кабинета, предоставляющую Партнёрам и Франчайзи безопасный доступ к релевантным данным (клиенты, сделки, базовая аналитика) и функциям (управление своими сотрудниками), с четким разделением на основе ролей.

#### **Backend (NestJS)**

* \[ \] **Задача 2.5.1: Доработка RBAC для поддержки ролей "Партнёр" и "Франчайзи".**  
  * **Контекст:** Обеспечение строгого разделения доступа к данным в соответствии с ТЗ 2.1, 2.4, 2.5. Это критически важная задача для безопасности и корректности работы кабинетов.  
  * **Тех. указания:**  
    1. \[ \] В Prisma schema убедиться, что сущности Contact и Deal имеют поле partnerId (связь с User, который является Партнёром/Франчайзи).  
    2. \[ \] В RolesGuard и/или через кастомные Ability-based guards (например, с использованием @casl/ability):  
       * \[ \] При доступе к спискам (GET /contacts, GET /deals): если текущий пользователь Партнёр/Франчайзи, автоматически добавлять фильтр WHERE partnerId \= currentUser.id.  
       * \[ \] При доступе к отдельным сущностям (GET /contacts/:id, GET /deals/:id): проверять, что entity.partnerId \=== currentUser.id.  
       * \[ \] При создании/обновлении (POST /contacts, PATCH /deals/:id): если создает Партнёр/Франчайзи, автоматически устанавливать partnerId \= currentUser.id. Запрещать изменение partnerId после создания, если это не Администратор.  
    3. \[ \] Тщательно протестировать все CRUD эндпоинты для Contacts и Deals с пользователями разных ролей (Администратор, Менеджер, Партнёр, Франчайзи), чтобы убедиться в корректной изоляции данных. Особое внимание уделить случаям, когда Партнёр пытается получить доступ к данным другого Партнёра.  
  * **Ожидаемый результат:**  
    * Обновленные гарды (RolesGuard или новые AbilityGuard) и сервисы (ContactsService, DealsService) с усиленной и протестированной логикой RBAC для изоляции данных Партнёров/Франчайзи.  
    * Набор автоматических тестов (юнит/интеграционных) для проверки сценариев доступа к данным для разных ролей.  
  * *Файлы: backend/src/auth/guards/\*\*, backend/src/contacts/contacts.service.ts, backend/src/deals/deals.service.ts, соответствующие файлы тестов.*  
* \[ \] **Задача 2.5.2: Разработка API для Единого Кабинета (агрегированные данные, специфичные для роли).**  
  * **Контекст:** Предоставление специфичных данных для дашбордов и разделов Единого Кабинета, адаптированных под роль пользователя (Партнёр/Франчайзи).  
  * **Тех. указания:**  
    1. \[ \] Создать CabinetModule, CabinetController, CabinetService.  
    2. \[ \] Эндпоинт GET /cabinet/dashboard-summary:  
       * \[ \] Возвращает агрегированные данные для дашборда текущего Партнёра/Франчайзи (фильтрация по currentUser.id как partnerId):  
         * \[ \] Количество активных клиентов.  
         * \[ \] Количество активных сделок.  
         * \[ \] Общая сумма активных сделок.  
         * \[ \] Конверсия (базовая, например, количество сделок / количество лидов за период).  
       * \[ \] CabinetService будет использовать ContactsService и DealsService для получения этих данных.  
    3. \[ \] Эндпоинт GET /cabinet/settings:  
       * \[ \] Возвращает специфичные настройки для кабинета Партнёра/Франчайзи (например, информация о компании, реквизиты, если они хранятся и управляются через CRM).  
    4. \[ \] Все эндпоинты в CabinetController должны быть защищены и доступны только для ролей PARTNER и FRANCHISEE.  
  * **Ожидаемый результат:**  
    * Код для CabinetModule, CabinetController, CabinetService.  
    * Юнит-тесты для CabinetService.  
  * *Файлы: backend/src/cabinet/\*\* (новая папка с модулем).*  
* \[ \] **Задача 2.5.3: API для управления Партнёрами/Франчайзи своими сотрудниками.**  
  * **Контекст:** Предоставление Партнёрам/Франчайзи возможности создавать пользователей с ролью PARTNER\_EMPLOYEE и управлять ими в рамках своих полномочий.  
  * **Тех. указания:**  
    1. \[ \] В CabinetController (или отдельном PartnerEmployeesController, вложенном в CabinetModule) создать эндпоинты:  
       * \[ \] GET /cabinet/employees: список сотрудников текущего Партнёра/Франчайзи (пользователи с ролью PARTNER\_EMPLOYEE и creatorId \= currentUser.id или аналогичная связь).  
       * \[ \] POST /cabinet/employees: создание нового сотрудника.  
         * \[ \] Payload: email, password, firstName, lastName.  
         * \[ \] Логика в CabinetService (или UsersService с доп. проверками):  
           * \[ \] Создает пользователя с ролью PARTNER\_EMPLOYEE.  
           * \[ \] Устанавливает partnerId (или managedByPartnerId) нового сотрудника равным currentUser.id.  
           * \[ \] Убедиться, что Партнёр не может назначить другую роль, кроме PARTNER\_EMPLOYEE.  
       * \[ \] GET /cabinet/employees/:employeeId: получение информации о своем сотруднике.  
       * \[ \] PATCH /cabinet/employees/:employeeId: обновление информации о своем сотруднике.  
       * \[ \] DELETE /cabinet/employees/:employeeId: "удаление" (деактивация) своего сотрудника.  
    2. \[ \] В Prisma schema для User добавить поле managedByPartnerId (опциональное, ссылка на User который является Партнёром/Франчайзи) или использовать существующее поле partnerId если оно подходит по семантике.  
    3. \[ \] Обновить RBAC, чтобы PARTNER\_EMPLOYEE имел доступ только к данным, связанным с managedByPartnerId.  
  * **Ожидаемый результат:**  
    * Новые API эндпоинты для управления сотрудниками.  
    * Обновленная Prisma schema и миграция.  
    * Обновленная логика RBAC для PARTNER\_EMPLOYEE.  
  * *Файлы: backend/src/cabinet/cabinet.controller.ts (или новый контроллер), backend/src/cabinet/cabinet.service.ts (или users.service.ts), backend/prisma/schema.prisma.*

#### **Frontend (Next.js)**

* \[ \] **Задача 2.6.1: Проектирование и разработка базовой структуры Единого Кабинета.**  
  * **Контекст:** Создание отдельного, визуально и функционально обособленного раздела для Партнёров/Франчайзи.  
  * **Тех. указания:**  
    1. \[ \] Создать новый layout с использованием App Router для Единого Кабинета: frontend/src/app/(cabinet)/layout.tsx. Этот layout может иметь другую навигацию/стили, чем основной админ-интерфейс.  
    2. \[ \] Реализовать навигационную панель (боковую или верхнюю) для кабинета. Пункты меню:  
       * \[ \] Дашборд (/cabinet/dashboard)  
       * \[ \] Мои Клиенты (/cabinet/contacts)  
       * \[ \] Мои Сделки (/cabinet/deals)  
       * \[ \] Мои Сотрудники (/cabinet/employees)  
       * \[ \] Аналитика (пока заглушка или ссылка на /cabinet/dashboard)  
       * \[ \] Обучение (заглушка, ТЗ 2.4)  
       * \[ \] Взаиморасчеты (заглушка, ТЗ 2.4)  
       * \[ \] Настройки Кабинета (заглушка)  
    3. \[ \] Использовать компоненты Mantine для структуры и навигации.  
  * **Ожидаемый результат:**  
    * Структура папок для Единого Кабинета.  
    * Файл layout.tsx для кабинета с навигацией.  
    * Базовые страницы-заглушки для каждого пункта меню.  
  * *Файлы: frontend/src/app/(cabinet)/layout.tsx (новый), frontend/src/app/(cabinet)/dashboard/page.tsx (новый), и другие страницы-заглушки в frontend/src/app/(cabinet)/.*  
* \[ \] **Задача 2.6.2: Реализация механизма автоматического определения отображаемого функционала на основе роли пользователя.**  
  * **Контекст:** Динамическое отображение UI (пункты меню, разделы на страницах) в зависимости от роли пользователя (Партнёр или Франчайзи) и, возможно, его грейда или других настроек.  
  * **Тех. указания:**  
    1. \[ \] В AuthProvider (или аналогичном месте, где хранится информация о текущем пользователе) убедиться, что доступна роль пользователя (user.role).  
    2. \[ \] В компоненте навигации Единого Кабинета и на страницах использовать эту роль для условного рендеринга:  
       * \[ \] Например, Франчайзи может видеть специфичный пункт меню "Аукцион лидов" (пока заглушка, ТЗ 2.5), которого нет у Партнёра.  
       * \[ \] Партнёр может видеть "Реферальная программа" (заглушка, ТЗ 2.4).  
       * \[ \] Разные блоки на дашборде могут отображаться в зависимости от роли.  
    3. \[ \] Создать хук useUserRole() или useAuth() для легкого доступа к роли пользователя в компонентах.  
  * **Ожидаемый результат:**  
    * Обновленный AuthProvider или хук для доступа к роли.  
    * Условный рендеринг в навигации и на страницах Единого Кабинета.  
  * *Файлы: frontend/src/contexts/AuthContext.tsx (обновление), frontend/src/app/(cabinet)/layout.tsx (обновление).*  
* \[ \] **Задача 2.6.3: Начальное отображение списков клиентов/лидов и сделок в Едином Кабинете.**  
  * **Контекст:** Предоставление Партнёрам/Франчайзи доступа к их данным по клиентам и сделкам через уже существующие компоненты таблиц/канбан.  
  * **Тех. указания:**  
    1. \[ \] Создать страницы в Едином Кабинете: /cabinet/contacts и /cabinet/deals.  
    2. \[ \] На этих страницах переиспользовать ранее созданные компоненты:  
       * \[ \] ContactsTable (для /cabinet/contacts).  
       * \[ \] DealsList (таблица) и/или DealsKanbanBoard (для /cabinet/deals).  
    3. \[ \] Убедиться, что эти компоненты корректно запрашивают данные с бэкенд API (/contacts, /deals). Бэкенд API уже должен фильтровать данные по partnerId на основе аутентифицированного пользователя.  
    4. \[ \] Проверить, что функционал создания/редактирования контактов/сделок из этих таблиц также работает корректно и новые сущности правильно привязываются к текущему Партнёру/Франчайзи.  
  * **Ожидаемый результат:**  
    * Функционирующие страницы со списками клиентов и сделок в Едином Кабинете, отображающие только данные текущего Партнёра/Франчайзи.  
  * *Файлы: frontend/src/app/(cabinet)/contacts/page.tsx (новый), frontend/src/app/(cabinet)/deals/page.tsx (новый).*  
* \[ \] **Задача 2.6.4: Базовая аналитика, доступная в Едином Кабинете.**  
  * **Контекст:** Отображение ключевых показателей эффективности для Партнёров/Франчайзи на их дашборде.  
  * **Тех. указания:**  
    1. \[ \] На странице /cabinet/dashboard (frontend/src/app/(cabinet)/dashboard/page.tsx):  
       * \[ \] Использовать API эндпоинт GET /cabinet/dashboard-summary для получения агрегированных данных.  
       * \[ \] Отобразить эти данные с помощью простых компонентов Mantine (например, StatsGrid, SimpleGrid с карточками Paper).  
       * \[ \] Показатели: "Мои активные клиенты", "Мои активные сделки", "Общая сумма моих сделок", "Моя конверсия".  
    2. \[ \] Визуализация может быть текстовой или с использованием простых иконок.  
  * **Ожидаемый результат:**  
    * Функционирующий дашборд в Едином Кабинете с отображением базовой аналитики для текущего Партнёра/Франчайзи.  
  * *Файлы: frontend/src/app/(cabinet)/dashboard/page.tsx (обновление).*  
* \[ \] **Задача 2.6.5: Реализация интерфейса для Партнёров/Франчайзи по созданию и управлению своими сотрудниками.**  
  * **Контекст:** Предоставление UI для управления командой сотрудников Партнёра/Франчайзи.  
  * **Тех. указания:**  
    1. \[ \] Создать страницу /cabinet/employees (frontend/src/app/(cabinet)/employees/page.tsx).  
    2. \[ \] Использовать TanStack Table для отображения списка сотрудников текущего Партнёра/Франчайзи (данные с GET /cabinet/employees). Колонки: ФИО, Email, Статус (активен/неактивен).  
    3. \[ \] Кнопка "Добавить сотрудника", открывающая модальное окно или отдельную страницу с формой (ContactForm или новый EmployeeForm).  
    4. \[ \] Форма для создания/редактирования сотрудника (React Hook Form \+ Mantine). Поля: Email, Пароль (только при создании), Имя, Фамилия.  
    5. \[ \] Интеграция с API POST /cabinet/employees, PATCH /cabinet/employees/:employeeId, DELETE /cabinet/employees/:employeeId.  
    6. \[ \] Обеспечить, чтобы Партнёр/Франчайзи мог управлять только своими сотрудниками.  
  * **Ожидаемый результат:**  
    * Функционирующий интерфейс для управления сотрудниками в Едином Кабинете.  
  * *Файлы: frontend/src/app/(cabinet)/employees/page.tsx (новый), frontend/src/components/Cabinet/EmployeeForm.tsx (новый), frontend/src/components/Cabinet/EmployeesTable.tsx (новый).*

## **Этап 3: Real-time, Фоновые задачи и Расширенный UI/UX (6-8 недель)**

**Цель этапа:** Внедрить WebSocket для обновлений в реальном времени (особенно для Франчайзи), настроить и полноценно использовать систему фоновых задач BullMQ, а также значительно улучшить пользовательский интерфейс за счет интерактивных элементов и адаптивности.

### **Спринт 11: Real-time отслеживание статусов заявок (2-3 недели)**

**Цель спринта:** Реализовать WebSocket для динамического отображения обновлений статусов заявок (сделок) для пользователей с ролью "Франчайзи" в Едином Кабинете.

#### **Backend (NestJS)**

* \[ \] **Задача 3.1.1: Разработка WebSocket Gateway (Socket.IO) для обновлений статусов.**  
  * **Контекст:** Создание сервера для real-time коммуникаций в соответствии с "Дополнением к ТЗ для ИИ", Задача 1.1.  
  * **Тех. указания:**  
    1. \[ \] Установить зависимости: npm install @nestjs/websockets @nestjs/platform-socket.io socket.io.  
    2. \[ \] Создать RealtimeModule (backend/src/realtime/realtime.module.ts).  
    3. \[ \] Создать RealtimeGateway (backend/src/realtime/realtime.gateway.ts):  
       * \[ \] Использовать декораторы @WebSocketGateway, @SubscribeMessage, @WebSocketServer.  
       * \[ \] Реализовать обработчики событий handleConnection и handleDisconnect для логирования подключений/отключений.  
       * \[ \] **Аутентификация WebSocket:** При подключении клиента (handleConnection) проверять JWT токен (переданный клиентом, например, в auth.token handshake query). Если токен валиден, ассоциировать socket.id с userId. Запрещать подключение без валидного токена.  
       * \[ \] Метод в RealtimeGateway для отправки сообщений клиентам в определенные "комнаты" (например, franchisee\_${franchiseeId}). Пользователь (Франчайзи) должен автоматически подписываться на свою комнату после успешной аутентификации соединения.  
       * \[ \] Событие для отправки: applicationStatusUpdated (payload: { dealId: string, newStatus: string, newStageName: string, details?: any }).  
  * **Ожидаемый результат:**  
    * Код для RealtimeGateway с аутентификацией подключений и управлением комнатами.  
  * *Файлы: backend/src/realtime/\*\* (новая папка с модулем).*  
* \[ \] **Задача 3.1.2: Настройка WebSocket адаптера для Redis.**  
  * **Контекст:** Обеспечение масштабируемости WebSocket сервера при использовании нескольких инстансов бэкенда (Дополнение к ТЗ для ИИ, Задача 1.2).  
  * **Тех. указания:**  
    1. \[ \] Установить Redis адаптер для Socket.IO: npm install @socket.io/redis-adapter.  
    2. \[ \] В main.ts или RealtimeModule настроить WebSocket-сервер (полученный через @WebSocketServer()) на использование Redis адаптера. Конфигурацию подключения к Redis взять из @nestjs/config.  
       // Пример в main.ts или RealtimeGateway  
       // import { createAdapter } from '@socket.io/redis-adapter';  
       // import { createClient } from 'redis';  
       // ...  
       // const pubClient \= createClient({ url: 'redis://localhost:6379' }); // Заменить на ConfigService  
       // const subClient \= pubClient.duplicate();  
       // await Promise.all(\[pubClient.connect(), subClient.connect()\]);  
       // io.adapter(createAdapter(pubClient, subClient));

  * **Ожидаемый результат:**  
    * Обновленная конфигурация WebSocket для использования Redis адаптера.  
  * *Файлы: backend/src/main.ts или backend/src/realtime/realtime.module.ts (обновление).*  
* \[ \] **Задача 3.1.3: Интеграция WebSocket Gateway с сервисами (например, DealsService).**  
  * **Контекст:** Отправка real-time уведомлений из бизнес-логики при изменении статусов сделок, релевантных для Франчайзи.  
  * **Тех. указания:**  
    1. \[ \] Внедрить RealtimeGateway в DealsService.  
    2. \[ \] В DealsService, в методе обновления сделки (особенно при изменении pipelineStageId), если сделка принадлежит Франчайзи (deal.partnerId указывает на Франчайзи), вызывать метод RealtimeGateway для эмиссии события applicationStatusUpdated в комнату этого Франчайзи (franchisee\_${deal.partnerId}).  
    3. \[ \] Передавать в payload события dealId, новый статус/этап и, возможно, другую релевантную информацию.  
  * **Ожидаемый результат:**  
    * Обновленный DealsService с логикой отправки WebSocket событий.  
  * *Файлы: backend/src/deals/deals.service.ts (обновление), backend/src/realtime/realtime.gateway.ts (обновление, если нужны доп. методы).*

#### **Frontend (Next.js)**

* \[ \] **Задача 3.2.1: Реализация WebSocket клиента в Едином Кабинете для пользователей с ролью "Франчайзи".**  
  * **Контекст:** Получение и динамическое отображение обновлений статусов сделок в реальном времени на стороне клиента (Дополнение к ТЗ для ИИ, Задача 1.3).  
  * **Тех. указания:**  
    1. \[ \] Установить socket.io-client: npm install socket.io-client.  
    2. \[ \] Создать React Context (например, SocketContext) для управления WebSocket соединением и его состоянием.  
    3. \[ \] В SocketProvider:  
       * \[ \] При монтировании (и если пользователь Франчайзи и аутентифицирован) устанавливать WebSocket соединение с бэкендом. Передавать JWT токен в auth.token handshake query: io(backendUrl, { auth: { token: accessToken } }).  
       * \[ \] Подписываться на событие applicationStatusUpdated.  
       * \[ \] При получении события обновлять состояние (например, через Zustand или Redux Toolkit, если используется, или через состояние самого контекста), чтобы затронутые компоненты перерендерились.  
       * \[ \] Обрабатывать события connect, disconnect, connect\_error. Реализовать логику переподключения.  
    4. \[ \] Обернуть Единый Кабинет (или его часть, где нужны real-time обновления) в SocketProvider.  
    5. \[ \] В компонентах, отображающих сделки Франчайзи (например, DealsKanbanBoard или DealsList в /cabinet/deals), получать обновленные данные из состояния, управляемого SocketContext, или напрямую обновлять локальное состояние компонента при получении события.  
  * **Ожидаемый результат:**  
    * Код для SocketContext и SocketProvider.  
    * Интеграция WebSocket клиента в Единый Кабинет Франчайзи.  
    * Динамическое обновление статусов сделок в UI без перезагрузки страницы.  
  * *Файлы: frontend/src/contexts/SocketContext.tsx (новый), frontend/src/app/(cabinet)/layout.tsx (обертка в провайдер), frontend/src/app/(cabinet)/deals/page.tsx (или компоненты DealsKanbanBoard.tsx, DealsList.tsx \- интеграция с контекстом).*

### **Спринт 12: Система фоновых задач и очередей (2-3 недели)**

**Цель спринта:** Полноценно настроить и интегрировать BullMQ для управления очередями и обработки различных фоновых задач (уведомления, синхронизации, автоматизации).

#### **Backend (NestJS/Redis)**

* \[ \] **Задача 3.3.1: Полноценная настройка и интеграция BullMQ.**  
  * **Контекст:** Финализация настройки BullMQ для управления очередями (Дополнение к ТЗ для ИИ, Задача 2.1). Ранее могли быть заглушки.  
  * **Тех. указания:**  
    1. \[ \] Установить зависимости: npm install bullmq @nestjs/bullmq.  
    2. \[ \] Создать JobsModule (backend/src/jobs/jobs.module.ts).  
    3. \[ \] В JobsModule настроить BullModule.forRootAsync для глобальной конфигурации подключения к Redis (используя ConfigService).  
    4. \[ \] Зарегистрировать все необходимые очереди с помощью BullModule.registerQueue:  
       * \[ \] notificationsQueue (для отправки email, SMS, Telegram уведомлений).  
       * \[ \] amoCRMSyncQueue (для задач синхронизации с AmoCRM).  
       * \[ \] pipelineActionsQueue (для выполнения действий автоматизации воронки продаж).  
       * \[ \] (Возможно) dataProcessingQueue (для длительных операций, таких как импорт/экспорт больших файлов).  
  * **Ожидаемый результат:**  
    * Настроенный JobsModule с зарегистрированными очередями BullMQ.  
  * *Файлы: backend/src/jobs/jobs.module.ts (новый или доработка), backend/src/app.module.ts (импорт JobsModule).*  
* \[ \] **Задача 3.3.2: Разработка сервисов-продюсеров и детализированных обработчиков задач.**  
  * **Контекст:** Реализация логики для постановки задач в очереди и их обработки в соответствии с "Дополнением к ТЗ для ИИ", Задачи 2.2, 2.3.  
  * **Тех. указания:**  
    1. \[ \] **Продюсеры задач:**  
       * \[ \] NotificationsService: создать методы для постановки задач в notificationsQueue (например, addEmailNotificationJob(to, subject, body), addTelegramNotificationJob(chatId, message)).  
       * \[ \] AmoCRMService: убедиться, что задачи для amoCRMSyncQueue корректно ставятся (из Задачи 2.1.3).  
       * \[ \] DealsService (или будущий PipelineAutomationService): методы для постановки задач в pipelineActionsQueue при срабатывании триггеров автоматизации.  
       * \[ \] ContactsService: для импорта/экспорта больших файлов ставить задачи в dataProcessingQueue.  
    2. \[ \] **Обработчики задач (Processors):**  
       * \[ \] Создать/доработать процессоры для каждой очереди в backend/src/jobs/processors/:  
         * \[ \] NotificationProcessor:  
           * \[ \] @Process('sendEmail'): логика отправки email (интеграция с email-сервисом, например, Nodemailer \+ SMTP или API сервиса типа SendGrid).  
           * \[ \] @Process('sendTelegramMessage'): использует TelegramService для отправки сообщения.  
         * \[ \] AmoCRMSyncProcessor: доработать логику из Задачи 2.1.3, добавить обработку ошибок, повторные попытки (retry strategies в BullMQ).  
         * \[ \] PipelineActionProcessor: будет обрабатывать задачи из pipelineActionsQueue (логика выполнения действий автоматизации, например, сменить этап сделки, создать задачу – пока базовые действия).  
         * \[ \] DataProcessingProcessor:  
           * \[ \] @Process('importContactsCsv'): логика парсинга CSV и создания/обновления контактов (из Задачи 1.3.4).  
           * \[ \] @Process('exportContactsCsv'): логика формирования CSV файла и сохранения его (или отправки ссылки пользователю).  
       * \[ \] Все обработчики должны использовать try-catch, логировать ошибки и результаты.  
  * **Ожидаемый результат:**  
    * Код для сервисов-продюсеров с логикой постановки задач.  
    * Код для детализированных обработчиков задач BullMQ с обработкой ошибок и логированием.  
    * Интеграция с сервисом отправки email.  
  * *Файлы: backend/src/notifications/notifications.service.ts (новый), backend/src/jobs/processors/notification.processor.ts (новый), backend/src/jobs/processors/amocrm-sync.processor.ts (доработка), backend/src/jobs/processors/pipeline-action.processor.ts (новый), backend/src/jobs/processors/data-processing.processor.ts (новый), обновления в ContactsService, DealsService.*  
* \[ \] **Задача 3.3.3: Настройка UI для мониторинга очередей (например, Arena или Bull Board).**  
  * **Контекст:** Предоставление Администратору инструмента для отслеживания состояния очередей и задач (Дополнение к ТЗ для ИИ, Задача 2.4).  
  * **Тех. указания:**  
    1. \[ \] Выбрать и установить UI-пакет для BullMQ (например, @bull-board/fastify или @bull-board/express с адаптером для NestJS). Рекомендация: @bull-board/nestjs и @bull-board/api, @bull-board/ui.  
       npm install @bull-board/api @bull-board/ui @bull-board/nestjs bullmq  
    2. \[ \] В main.ts или отдельном AdminModule настроить BullBoard UI:  
       * \[ \] Создать адаптеры для всех зарегистрированных очередей BullMQ.  
       * \[ \] Настроить базовый путь для UI (например, /admin/queues).  
       * \[ \] Защитить доступ к этому UI с помощью AdminGuard или аналогичного механизма (только для роли ADMIN).  
  * **Ожидаемый результат:**  
    * Рабочий UI для мониторинга очередей BullMQ, доступный администраторам.  
  * *Файлы: backend/src/main.ts (обновление) или backend/src/admin/admin.module.ts (если UI для очередей там).*

### **Спринт 13: Расширенный UI/UX (Drag\&Drop, Inline-редактирование) (2-3 недели)**

**Цель спринта:** Значительно улучшить интерактивность и удобство использования интерфейса, реализовав Drag\&Drop для канбан-доски, inline-редактирование в таблицах и доработав трехколоночный интерфейс сделок, а также общую адаптивность.

#### **Frontend (Next.js)**

* \[ \] **Задача 3.4.1: Полноценная реализация Drag\&Drop для канбан-доски сделок (dnd-kit).**  
  * **Контекст:** Улучшение канбан-доски для управления этапами сделок (ТЗ 2.3). Базовая реализация была в Спринте 5, здесь требуется финализация и улучшение UX.  
  * **Тех. указания:**  
    1. \[ \] Использовать dnd-kit (@dnd-kit/core, @dnd-kit/sortable).  
    2. \[ \] Обеспечить плавное перетаскивание карточек сделок между колонками (этапами воронки).  
    3. \[ \] При успешном "бросании" карточки в новую колонку:  
       * \[ \] Оптимистичное обновление UI (карточка сразу перемещается).  
       * \[ \] Отправка запроса на бэкенд (PATCH /deals/:dealId) для обновления pipelineStageId сделки.  
       * \[ \] Обработка возможных ошибок от бэкенда (например, откат оптимистичного обновления или отображение сообщения об ошибке).  
    4. \[ \] Визуальная обратная связь:  
       * \[ \] Стилизация перетаскиваемого элемента (например, легкая тень, изменение прозрачности).  
       * \[ \] Подсветка доступных зон для "бросания" (колонок).  
       * \[ \] Плейсхолдер на месте, откуда карточка была взята.  
    5. \[ \] **Доступность (a11y):** Реализовать возможность управления перемещением сделок с клавиатуры (например, используя инструкции и примеры из документации dnd-kit для keyboard support).  
    6. \[ \] Рассмотреть возможность перетаскивания колонок (этапов) для изменения их порядка (если это требуется по ТЗ, для Администратора).  
  * **Ожидаемый результат:**  
    * Функциональная и визуально привлекательная канбан-доска с плавным Drag\&Drop.  
    * Улучшенная доступность для управления с клавиатуры.  
  * *Файлы: frontend/src/components/Deals/DealsKanbanBoard.tsx (значительная доработка), frontend/src/app/deals/page.tsx (обновление, если нужно).*  
* \[ \] **Задача 3.4.2: Реализация Inline-редактирования в таблицах (TanStack Table).**  
  * **Контекст:** Предоставление пользователям возможности быстрого редактирования данных непосредственно в таблицах Клиентов и Сделок (ТЗ 2.3).  
  * **Тех. указания:**  
    1. \[ \] Использовать возможности TanStack Table (v8+) для inline-редактирования.  
    2. \[ \] Для ContactsTable (frontend/src/components/Contacts/ContactsTable.tsx):  
       * \[ \] Определить редактируемые поля (например, ФИО, телефон, email, статус).  
       * \[ \] При клике на ячейку (или специальную иконку редактирования) она должна заменяться на соответствующий инпут Mantine (TextInput, Select для статуса).  
       * \[ \] При потере фокуса (onBlur) или нажатии Enter:  
         * \[ \] Валидировать введенное значение.  
         * \[ \] Если валидно, отправлять PATCH запрос на бэкенд для обновления соответствующего поля контакта.  
         * \[ \] Оптимистичное обновление ячейки в таблице или обновление данных таблицы после успешного ответа от бэкенда.  
    3. \[ \] Аналогично для DealsTable (если используется табличное представление сделок, например, в /deals или в Едином Кабинете):  
       * \[ \] Редактируемые поля (например, Название сделки, Сумма, Статус/Этап).  
    4. \[ \] Обеспечить визуальную индикацию редактируемых ячеек и процесса сохранения.  
    5. \[ \] Обработка ошибок сохранения (например, отображение сообщения рядом с ячейкой).  
  * **Ожидаемый результат:**  
    * Таблицы ContactsTable и DealsTable с возможностью inline-редактирования ключевых полей.  
  * *Файлы: frontend/src/components/Contacts/ContactsTable.tsx (доработка), frontend/src/components/Deals/DealsList.tsx (если есть таблица сделок, доработка).*  
* \[ \] **Задача 3.4.3: Доработка трехколоночного интерфейса для работы со сделками.**  
  * **Контекст:** Улучшение и детализация страницы просмотра/редактирования отдельной сделки в соответствии с ТЗ 2.3.  
  * **Тех. указания:**  
    1. \[ \] Страница /deals/\[dealId\]/page.tsx (или аналогичный компонент, если используется модальное окно).  
    2. \[ \] **Левая колонка (Информация о клиенте/сделке):**  
       * \[ \] Детальная информация о сделке (все поля модели Deal).  
       * \[ \] Краткая информация о связанном клиенте (Contact) с возможностью перехода на полную карточку клиента.  
       * \[ \] Возможность редактирования полей сделки (например, кнопка "Редактировать", открывающая модальное окно с DealForm, или inline-редактирование).  
    3. \[ \] **Центральная колонка (История взаимодействия):**  
       * \[ \] Лента активности по сделке:  
         * \[ \] Комментарии к сделке (отображение существующих, форма для добавления нового комментария \- API POST /deals/:dealId/comments).  
         * \[ \] История изменений ключевых полей сделки (например, смена этапа, суммы, ответственного – требует логирования этих изменений на бэкенде и API для их получения).  
         * \[ \] Задачи, связанные со сделкой (пока можно отображать заглушку или базовый список задач, если модель Task и API для них будут созданы).  
    4. \[ \] **Правая колонка (Панель автоматизаций):**  
       * \[ \] На данном этапе эта колонка может содержать заглушку "Автоматизации будут доступны здесь" или отображать список примененных/доступных автоматизаций для текущего этапа (если базовая логика автоматизаций уже есть на бэкенде).  
    5. \[ \] Использовать компоненты Mantine (Grid, Paper, Timeline, Tabs и т.д.) для структурирования информации.  
    6. \[ \] Интерфейс должен быть адаптивным.  
  * **Ожидаемый результат:**  
    * Функциональный и информативный трехколоночный интерфейс для страницы сделки.  
    * API на бэкенде для добавления комментариев к сделкам и получения истории изменений сделки.  
  * *Файлы: frontend/src/app/deals/\[dealId\]/page.tsx (значительная доработка или создание), backend/src/deals/deals.controller.ts (новые эндпоинты для комментариев, истории), backend/src/deals/deals.service.ts (логика для комментариев, истории).*  
* \[ \] **Задача 3.4.4: Улучшение адаптивности и общей отзывчивости интерфейса.**  
  * **Контекст:** Обеспечение корректного и удобного отображения всех ключевых страниц и компонентов на различных устройствах (десктопы, планшеты, мобильные).  
  * **Тех. указания:**  
    1. \[ \] Провести ревью всех существующих страниц и компонентов на адаптивность:  
       * \[ \] Дашборды (администратора, Единого Кабинета).  
       * \[ \] Списки (контакты, сделки, пользователи).  
       * \[ \] Формы (создания/редактирования).  
       * \[ \] Канбан-доска.  
       * \[ \] Страница отдельной сделки (трехколоночная).  
       * \[ \] Модальные окна.  
    2. \[ \] Использовать адаптивные возможности Mantine (скрытие/показ элементов, изменение Grid, Stack и т.д. на разных брейкпоинтах) и Tailwind CSS.  
    3. \[ \] Для таблиц на мобильных устройствах рассмотреть варианты: горизонтальный скролл, трансформация в карточки, или отображение только самых важных колонок.  
    4. \[ \] Протестировать на реальных устройствах или с помощью инструментов разработчика в браузере.  
    5. \[ \] Обеспечить, чтобы все интерактивные элементы были удобны для использования на сенсорных экранах (достаточный размер, отступы).  
  * **Ожидаемый результат:**  
    * Значительно улучшенная адаптивность и отзывчивость всего интерфейса.  
    * Устранены проблемы с версткой на разных разрешениях.  
  * *Файлы: Множественные файлы компонентов и страниц в frontend/src/, файлы стилей (если есть кастомные).*