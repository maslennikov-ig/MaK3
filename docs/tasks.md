---

> **Внимание:** Документ разбит на несколько частей из-за большого объёма. Продолжение смотри в файлах [tasks 2.md](./tasks%202.md) и [tasks 3.md](./tasks%203.md).

## Внутренние документы проекта

- [architecture.md — Архитектура](./architecture.md)
- [infrastructure.md — Инфраструктура](./infrastructure.md)
- [project-structure.md — Структура проекта](./project-structure.md)
- [roadmap.md — Дорожная карта](./roadmap.md)
- [changelog.md — Журнал изменений](./changelog.md)
- [questions-to-tz.md — Вопросы к ТЗ](./questions-to-tz.md)
- [ТЗ_CRM_2025.md — Основное ТЗ](./ТЗ_CRM_2025.md)

---

## **Правила работы с задачами (дополненные)**

* Всегда сначала ищем готовую, поддерживаемую библиотеку или компонент, а не пишем с нуля.
* Предпочитаем использовать самые новые, но стабильные версии библиотек, компонентов и модулей.
* Если возникает проблема с зависимостями, и нет возможности обновить до последних стабильных версий — отказываемся от проблемного модуля и ищем современную альтернативу, а не фиксируем старую зависимость.

* Всегда предлагайте архитектурные улучшения или альтернативные варианты, если это может повысить модульность, читаемость или масштабируемость системы.
* Используйте современные best practices для выбранных технологий (например, Server Components в Next.js, feature/domain-based структура, паттерны NestJS/Prisma).
* При необходимости обращайтесь к официальной документации и используйте Context7 для поиска актуальных решений, ссылайтесь на источники.
* Для задач по безопасности явно указывайте потенциальные риски и способы их минимизации (особенно для аутентификации/авторизации, работы с данными, интеграций).

* Отмечайте выполненные задачи как [x]  
* Запрашивайте одобрение пользователя перед началом следующей фазы.
* Если есть задачи для разработчика, сообщай об этом в чате и жди от него подтверждения выполнения  
* Указывайте измененные файлы рядом с задачей (в комментарии или подпункте).  
* Не отмечайте будущие задачи как выполненные, пока не получите явного запроса.  
* Задачи сгруппированы по фазам разработки. Следуйте порядку.  
* Используйте единообразное именование и структуру при добавлении новых задач.  
* При необходимости добавляйте ссылки на документацию или ресурсы.  
* Если задача заблокирована, четко укажите причину и зависимости.  
* Проверяйте завершенные фазы на полноту перед переходом к следующей.  
* По желанию добавляйте временные метки для отслеживания прогресса.  
* Используйте встроенные комментарии для примечаний или обоснования изменений.
* **Контекст и Цель:** Каждая задача должна начинаться с краткого описания цели (Что мы хотим достичь?) и контекста (Какая часть системы затрагивается? Какие есть зависимости?).  
* **Ожидаемый Результат (Acceptance Criteria):** Четко определить, что считается успешным выполнением задачи (например, "сгенерирован код модуля X с покрытием тестами Y%", "создана схема БД для Z", "настроен CI/CD пайплайн, который выполняет A, B, C").  
* **Технологические Указания:** Указывать конкретные технологии, библиотеки, версии (если критично), паттерны проектирования, которые ИИ должен использовать.  
* **Примеры (если применимо):** Предоставлять небольшие примеры кода, структуры данных или ожидаемого вывода.  
* **Нефункциональные Требования:** Упоминать релевантные нефункциональные требования (производительность, безопасность, читаемость кода, логирование) для конкретной задачи.  
* **Итеративность:** Для сложных задач предлагать ИИ разбить их на подзадачи или генерировать решение по частям, запрашивая обратную связь.  
* **Формат Вывода:** Указывать желаемый формат вывода (например, "предоставить код в виде файла .ts", "сгенерировать Prisma schema", "предоставить команду для Docker CLI").  
* **Вопросы для Уточнения:** Поощрять ИИ задавать уточняющие вопросы, если задача недостаточно ясна.  
* **Фокус на Безопасности:** Для задач, связанных с данными или аутентификацией, явно указывать на необходимость учета аспектов безопасности (например, "реализовать с учетом защиты от XSS", "использовать параметризованные запросы").  
* **Документирование Кода:** Требовать генерации комментариев к коду (TSDoc/JSDoc) для всех публичных функций и сложной логики.  
* **Генерация Тестов:** Для большинства задач по генерации кода требовать также генерации соответствующих юнит-тестов.  
* **Указание на Файлы:** Просить ИИ указывать, какие файлы были созданы или модифицированы.

## **Этап 0: Подготовка, планирование и настройка (3-4 недели)**

**Цель этапа:** Заложить фундамент для разработки, настроить окружение, финализировать архитектуру и подготовить инструменты.

**Общие задачи для ИИ на этапе:**

* Помощь в анализе ТЗ и генерации вопросов для уточнения.  
* Генерация конфигурационных файлов.  
* Написание скриптов для автоматизации.  
* Генерация базовой структуры проектов.  
* Помощь в проектировании схем БД и API.

### **Задача 0.1: Глубокое изучение ТЗ и "Дополнения к ТЗ для ИИ"**

* \[x\] **Проанализировать ТЗ (файл "ТЗ\_CRM\_2025") (из дорожной карты, раздел 5). Сформировать список из 5-10 ключевых вопросов для разработчика, направленных на уточнение неясных моментов или потенциальных противоречий, особенно в контексте модульности и ролей "Партнёр"/"Франчайзи".**  
  * **Ожидаемый результат:** Список вопросов.  
  * **Фокус:** Понимание требований к MVP, архитектуре каталога компонентов, иерархии прав.
  * **Выполнено:** Создан файл questions-to-tz.md с 20 вопросами по модульности, ролям "Партнёр"/"Франчайзи", техническим аспектам и бизнес-требованиям.

### **Задача 0.2: Настройка инфраструктуры разработки**

* \[x\] **Создание репозитория:** (Задача для разработчика, ИИ может помочь с README.md)  
  * \[x\] **Сгенерировать базовый README.md для проекта MaK CRM.**  
    * **Контекст:** Файл будет в корне репозитория.  
    * **Тех. указания:** Включить разделы: "Описание проекта", "Технологический стек" (взять из дорожной карты), "Настройка окружения (кратко)", "Запуск проекта (локально)".  
    * **Ожидаемый результат:** Текст для README.md.  
    * **Выполнено:** Создан файл README.md с описанием проекта, технологическим стеком, инструкциями по настройке окружения и запуску проекта.
* \[x\] **Настройка базового CI/CD пайплайна (GitHub Actions):**  
  * \[x\] **Сгенерировать workflow-файл для GitHub Actions (.github/workflows/ci.yml).**  
    * **Контекст:** Пайплайн для автоматической проверки кода при push в ветки main и develop, а также для Pull Requests.  
    * **Тех. указания:** Должен включать шаги:  
      1. Checkout кода.  
      2. Настройка Node.js (например, v18.x или v20.x).  
      3. Установка зависимостей (npm ci или yarn install).  
      4. Линтинг (ESLint).  
      5. Форматирование (Prettier \--check).  
      6. Запуск юнит-тестов (команда будет npm test или yarn test, пока можно оставить заглушку или базовую команду).  
      7. (Опционально, но желательно) Сборка Docker-образов для frontend и backend (пока без push в registry).  
    * **Ожидаемый результат:** Содержимое файла ci.yml.  
    * **Фокус:** Раннее обнаружение ошибок, консистентность кода.  
    * **Выполнено:** Создан файл .github/workflows/ci.yml с настройкой CI/CD пайплайна для автоматической проверки кода.
* \[x\] **Настройка локального окружения разработки с Docker Compose:**  
  * \[x\] **Сгенерировать файл docker-compose.yml для локальной разработки.**  
    * **Контекст:** Обеспечить запуск всех необходимых сервисов одной командой.  
    * **Тех. указания:** Включить сервисы:  
      1. frontend (Next.js, пока можно использовать базовый образ node и команду для запуска dev-сервера, позже доработаем Dockerfile).  
      2. backend (NestJS, аналогично frontend).  
      3. postgres (официальный образ PostgreSQL, указать версию, например 15 или 16). Настроить тома (volumes) для сохранения данных (./.pgdata:/var/lib/postgresql/data). Задать переменные окружения для пользователя, пароля, имени БД (например, POSTGRES\_USER, POSTGRES\_PASSWORD, POSTGRES\_DB).  
      4. redis (официальный образ Redis, указать версию). Настроить тома для данных.  
      5. elasticsearch (официальный образ Elasticsearch, указать версию). Настроить тома, переменные окружения (например, discovery.type=single-node, настройки для разработки).  
    * **Ожидаемый результат:** Содержимое файла docker-compose.yml.  
    * **Дополнительно:** Сгенерировать пример файла .env для docker-compose.yml с необходимыми переменными.  
    * **Выполнено:** Создан файл docker-compose.yml с настройкой всех необходимых сервисов и файл .env с переменными окружения.
* \[x\] **Подготовка базовой инфраструктуры в Яндекс.Облаке (или выбранном провайдере):** (Больше задача для разработчика, ИИ может помочь со скриптами)  
  * \[x\] **Сгенерировать пример Terraform-конфигурации (или Ansible playbook, или Yandex Cloud CLI скрипт) для создания управляемой инстанса PostgreSQL в Яндекс.Облаке.**  
    * **Контекст:** Подготовка к будущим развертываниям.  
    * **Тех. указания:** Включить базовые параметры: тип инстанса, размер диска, регион, настройки сети (для примера). Указать на необходимость безопасного управления кредами.  
    * **Ожидаемый результат:** Пример кода для выбранного инструмента IaC.  
    * **Выполнено:** Создан файл infrastructure/terraform/yandex-cloud/main.tf с Terraform-конфигурацией для создания управляемой инстанса PostgreSQL в Яндекс.Облаке.

### **Задача 0.3: Детализация архитектуры и начальное проектирование**

* \[x\] **Финализация высокоуровневой технической архитектуры:** (Разработчик \+ ИИ для генерации диаграмм/документации)  
  * \[x\] **На основе ТЗ и дорожной карты, сгенерировать текстовое описание и диаграмму (в формате Mermaid.js или PlantUML) для архитектуры C4 Model: Уровень 1 (System Context) и Уровень 2 (Containers).**  
    * **Контекст:** Визуализация основных компонентов системы и их взаимодействий.  
    * **Тех. указания:** Учесть Frontend, Backend, Базы данных (PostgreSQL, Redis, Elasticsearch), Object Storage, Очереди (BullMQ), Внешние интеграции (AmoCRM, Telegram).  
    * **Ожидаемый результат:** Текстовое описание и код для генерации диаграмм.  
* \[x\] **Проектирование системы с учетом будущей архитектуры "Каталога компонентов":**  
  * \[x\] **Предложить 2-3 варианта базовой структуры модулей для NestJS (backend) и Next.js (frontend), которые облегчат последующее выделение функциональности в независимые компоненты/модули каталога.**  
    * **Контекст:** Заложить основу для модульности.  
    * **Тех. указания:** Рассмотреть feature-based структуру, domain-based структуру. Для NestJS – использование модулей NestJS. Для Next.js – организация папок в app router.  
    * **Ожидаемый результат:** Описание вариантов структуры с примерами иерархии папок.  
* \[x\] **Проектирование схемы основной БД (PostgreSQL) с использованием Prisma Schema:**  
  * \[x\] **Сгенерировать начальную Prisma schema (schema.prisma) для сущностей: User, Role, Permission.**  
    * **Контекст:** Основа для аутентификации и авторизации.  
    * **Тех. указания:**  
      * User: id (uuid, default: uuid()), email (unique), passwordHash, firstName, lastName, isActive (boolean, default: true), createdAt, updatedAt. Связь с Role.  
      * Role: id (uuid), name (unique, enum: ADMIN, MANAGER, BROKER, PARTNER, FRANCHISEE, PARTNER\_EMPLOYEE), description. Связь с User (many-to-many или one-to-many если у юзера одна роль). Связь с Permission (many-to-many).  
      * Permission: id (uuid), action (string, e.g., create:client, read:deal), subject (string, e.g., client, deal).  
      * Использовать @default(now()) и @updatedAt.  
      * Указать datasource db { provider \= "postgresql", url \= env("DATABASE\_URL") } и generator client { provider \= "prisma-client-js" }.  
    * **Ожидаемый результат:** Содержимое файла schema.prisma.  
    * **Фокус:** Безопасность (не хранить пароли в открытом виде), гибкость RBAC.  
    * **Выполнено:** Создан файл backend/prisma/schema.prisma с определением всех необходимых моделей и связей между ними.
  * \[x\] **Сгенерировать команду для создания начальной миграции Prisma на основе созданной схемы.**  
    * **Ожидаемый результат:** Команда CLI (например, npx prisma migrate dev \--name init\_users\_roles).  
* \[x\] **Проектирование базовых API эндпоинтов (OpenAPI/Swagger спецификации):**  
  * \[x\] **Сгенерировать OpenAPI (v3) спецификацию в формате YAML для модуля аутентификации.**  
    * **Контекст:** Описание API для регистрации, входа, выхода, обновления токена.  
    * **Тех. указания:** Эндпоинты:  
      * POST /auth/register (RequestBody: email, password, firstName, lastName; Response: User info, accessToken, refreshToken)  
      * POST /auth/login (RequestBody: email, password; Response: User info, accessToken, refreshToken)  
      * POST /auth/logout (защищенный, использует refreshToken)  
      * POST /auth/refresh-token (RequestBody: refreshToken; Response: accessToken, refreshToken)  
      * Определить DTO для запросов и ответов, включая примеры. Указать коды ответов (200, 201, 400, 401, 403).  
    * **Ожидаемый результат:** Содержимое YAML файла спецификации.  
* \[x\] **Планирование структуры модулей для NestJS и Next.js:** (частично покрыто выше)  
  * \[x\] **Для NestJS: предложить структуру для модуля AuthModule, включая контроллер, сервис, DTOs, guards, strategies (JWT).**  
    * **Ожидаемый результат:** Иерархия папок и файлов с кратким описанием назначения каждого.  
    * **Выполнено:** Реализована структура модуля AuthModule с необходимыми компонентами: контроллер, сервис, DTO, гварды и стратегии.
  * \[x\] **Для Next.js: предложить структуру для страниц аутентификации (/login, /register) в app router, включая использование Server Components и Client Components для форм.**  
    * **Ожидаемый результат:** Иерархия папок и файлов.
    * **Выполнено:** Реализована структура страниц аутентификации в папке app/(auth) с поддержкой форм входа и регистрации.

### **Задача 0.4: Выбор и настройка инструментов**

* \[x\] **Настройка IDE:** 
* \[x\] **Настройка ESLint, Prettier:**  
  * \[x\] **Сгенерировать конфигурационные файлы для ESLint (.eslintrc.js или .json) и Prettier (.prettierrc.js или .json, .prettierignore).**  
    * **Контекст:** Обеспечение единого стиля кода и отлов ошибок.  
    * **Тех. указания:**  
      * ESLint: для TypeScript, React (если фронтенд), NestJS (если бэкенд). Включить рекомендуемые правила, плагины (например, @typescript-eslint/eslint-plugin, eslint-plugin-react, eslint-plugin-prettier).  
      * Prettier: базовые настройки (tabWidth, semi, singleQuote и т.д.).  
    * **Ожидаемый результат:** Содержимое конфигурационных файлов.  
    * **Выполнено:** Созданы конфигурационные файлы .eslintrc.json и .prettierrc для frontend и backend, а также файлы .prettierignore.
  * \[x\] **Сгенерировать команды npm/yarn для установки ESLint, Prettier и их зависимостей в package.json (dev-зависимости).**  
    * **Ожидаемый результат:** Список команд.  
    * **Выполнено:** Добавлены все необходимые зависимости в package.json для frontend и backend.
  * \[x\] **Добавить скрипты lint и format в package.json.**  
    * **Ожидаемый результат:** Фрагмент для package.json.  
    * **Выполнено:** Добавлены скрипты lint, format и format:check в package.json для frontend и backend.
* \[x\] **Выбор и первичная настройка системы управления проектом/задачами:** (Задача разработчика)

## Этап 1: Базовая CRM – Ядро и Пользователи (MVP Часть 1) (8-10 недель)

**Цель этапа:** Реализовать основной функционал CRM, включая управление пользователями, клиентами, лидами и сделками.

### Спринт 1-2: Ядро Backend и Аутентификация (3-4 недели)

**Цель спринтов:** Создать работающее ядро бэкенда с системой аутентификации и базовой авторизацией, а также настроить фронтенд для взаимодействия с ним.

#### **Backend (NestJS)**

* \[x\] **Задача 1.1.1: Создание базовой структуры проекта NestJS.**  
  * **Контекст:** Инициализация нового NestJS проекта.  
  * **Тех. указания:** Использовать Nest CLI: nest new backend \--package-manager npm (или yarn/pnpm).  
  * **Ожидаемый результат:** Сгенерированный проект NestJS. 
  * *Файлы: вся папка backend*  
  * **Выполнено:** Создана базовая структура проекта NestJS с настроенными модулями и конфигурацией.
* \[x\] **Задача 1.1.2: Настройка Prisma ORM и подключение к PostgreSQL.**  
  * **Контекст:** Интеграция Prisma для взаимодействия с БД.  
  * **Тех. указания:**  
    1. Установить Prisma CLI и Prisma Client: npm install prisma \--save-dev, npm install @prisma/client.  
    2. Инициализировать Prisma: npx prisma init \--datasource-provider postgresql. (ИИ предоставляет команды)  
    3. Обновить .env файл в backend с DATABASE\_URL (пример: postgresql://user:password@localhost:5432/makcrm\_dev?schema=public).  
  * **Выполнено:** Установлены Prisma CLI и Prisma Client, создан PrismaModule и PrismaService для взаимодействия с БД, настроены переменные окружения в .env.
    4. Создать PrismaService в NestJS (src/prisma/prisma.service.ts) который инкапсулирует PrismaClient и обрабатывает подключение/отключение.  
    5. Зарегистрировать PrismaModule (создать src/prisma/prisma.module.ts) и импортировать его глобально в AppModule.  
  * **Ожидаемый результат:** Код для PrismaService, PrismaModule, обновленный AppModule. Команды для CLI.  
  * *Файлы: backend/prisma/schema.prisma (уже есть из Этапа 0), backend/.env, backend/src/prisma/prisma.service.ts, backend/src/prisma/prisma.module.ts, backend/src/app.module.ts*  
* \[x\] **Задача 1.1.3: Реализация базовой конфигурации (переменные окружения).**  
  * **Контекст:** Управление конфигурацией приложения через переменные окружения.  
  * **Тех. указания:**  
    1. Использовать @nestjs/config. Установить: npm install @nestjs/config.  
    2. Настроить ConfigModule в AppModule (ConfigModule.forRoot({ isGlobal: true })).  
    3. Определить переменные окружения для JWT секрета, срока жизни токенов, порта приложения в .env.  
    4. Создать файл валидации для переменных окружения с использованием Joi или class-validator.  
  * **Ожидаемый результат:** Обновленный AppModule, пример .env с новыми переменными, код для валидации конфигурации.  
  * *Файлы: backend/src/app.module.ts, backend/.env, backend/src/config/env.validation.ts (новый)*  
  * **Выполнено:** Создан файл валидации переменных окружения, настроен ConfigModule в AppModule, созданы файлы .env и .env.example с необходимыми переменными (10.05.2025).
* \[x\] **Задача 1.1.4: Настройка логирования (интеграция с Sentry на базовом уровне).**  
  * **Контекст:** Отслеживание ошибок и событий в приложении.  
  * **Тех. указания:**  
    1. Установить Sentry SDK для NestJS: npm install \--save @sentry/node @sentry/profiling-node.  
    2. Инициализировать Sentry в main.ts с DSN из переменной окружения.  
    3. Настроить базовый SentryInterceptor для автоматического отлова исключений.  
    4. Добавить пример логирования кастомного события с помощью Sentry.  
  * **Ожидаемый результат:** Обновленный main.ts, код для SentryInterceptor, пример использования.  
  * *Файлы: backend/src/main.ts, backend/src/sentry.interceptor.ts (новый)*  
  * **Выполнено:** Создан SentryInterceptor, настроена инициализация Sentry в main.ts, добавлены необходимые зависимости (10.05.2025).
* \[x\] **Задача 1.1.5: Реализация JWT аутентификации (регистрация, вход, выход, обновление токена).**  
  * **Контекст:** Обеспечение безопасного доступа к системе.  
  * **Тех. указания:**  
    1. Реализовать модуль AuthModule с использованием @nestjs/jwt и passport.  
    2. Создать сервис для регистрации, входа, выхода и обновления токена.  
    3. Реализовать гварды для защиты маршрутов.  
    4. Создать декораторы для публичных маршрутов и ролей.  
  * **Ожидаемый результат:** Полноценный модуль аутентификации с контроллером, сервисом и гвардами.  
  * *Файлы: backend/src/auth/*, backend/src/common/guards/*, backend/src/common/decorators/**  
  * **Выполнено:** Реализованы все необходимые компоненты для JWT аутентификации, включая модуль, сервис, контроллер, стратегии и гварды. Добавлены необходимые изменения в схему Prisma (10.05.2025).
  * *Файлы: backend/src/auth/\*\* (новая папка с модулем)*  
* \[x\] **Задача 1.1.6: Создание базовых сущностей для Пользователей и Ролей (Prisma Schema уже есть). Реализация RBAC (гарды, декораторы) \- основа.**  
  * **Контекст:** Управление доступом на основе ролей.  
  * **Тех. указания:**  
    1. Создать RolesGuard (src/auth/guards/roles.guard.ts).  
  * **Выполнено:** Реализованы декораторы для ролей и гвард для проверки ролей. Добавлены методы в UsersService для назначения ролей и проверки прав управления. В UsersController добавлены эндпоинты для работы с ролями. В схеме Prisma обновлена модель User для хранения ролей (10.05.2025).
    2. Создать декоратор @Roles(...roles: Role\[\]) (src/auth/decorators/roles.decorator.ts) для указания разрешенных ролей на эндпоинтах.  
    3. В AuthService или отдельном UserService реализовать методы для назначения ролей пользователям (пока можно хардкодить при создании или через Prisma Studio).  
    4. Доработать JwtStrategy для включения ролей пользователя в payload токена или загрузки их при валидации.  
    5. Продумать механизм иерархии прав (Партнёры/Франчайзи управляют правами своих сотрудников). На этом этапе достаточно заложить основу: при проверке прав в RolesGuard учитывать, что PARTNER может управлять PARTNER\_EMPLOYEE.  
  * **Ожидаемый результат:** Код для RolesGuard, @Roles декоратора, обновленный JwtStrategy.  
  * *Файлы: backend/src/auth/guards/roles.guard.ts, backend/src/auth/decorators/roles.decorator.ts, backend/src/auth/strategies/jwt.strategy.ts*  
* \[x\] **Задача 1.1.7: Реализация API для управления пользователями (CRUD).**
  * **Контекст:** Создание, чтение, обновление, удаление пользователей администратором.
  * **Тех. указания:**
    1. Создать UsersController (src/users/users.controller.ts) с эндпоинтами:
       * GET /users (список пользователей, с пагинацией, защищено JwtAuthGuard и @Roles('ADMIN')).
       * POST /users (создание пользователя, @Roles('ADMIN')). Администратор назначает роль при создании (включая "Партнёр", "Франчайзи").
       * GET /users/:id (получение пользователя по ID, @Roles('ADMIN')).
       * PATCH /users/:id (обновление пользователя, @Roles('ADMIN')).
       * DELETE /users/:id (удаление пользователя, @Roles('ADMIN')).
    2. Создать UsersService (src/users/users.service.ts) с бизнес-логикой CRUD, используя PrismaService.
    3. Создать DTO для создания (CreateUserDto) и обновления (UpdateUserDto) пользователя с валидацией. CreateUserDto должен включать поле для назначения роли.
  * **Ожидаемый результат:** Код для UsersModule, UsersController, UsersService, DTOs. Юнит-тесты для UsersService.  
  * *Файлы: backend/src/users/\*\* (новая папка с модулем)*
  * **Выполнено:** Реализовано полное API для управления пользователями с CRUD операциями. Созданы DTO для создания и обновления пользователей с валидацией полей. Все эндпоинты защищены с помощью JwtAuthGuard и RolesGuard. Реализована бизнес-логика в UsersService для обработки запросов (11.05.2025).

#### **Frontend (Next.js)**

* \[x\] **Задача 1.2.1: Создание базовой структуры проекта Next.js с App Router.**
  * **Контекст:** Настройка фронтенд-части приложения.  
  * **Тех. указания:**  
    1. Создать проект Next.js: npx create-next-app@latest frontend --typescript --eslint --app --src-dir --import-alias @/\*.  
    2. Настроить базовую структуру папок: app/(auth), app/(dashboard), components, hooks, lib, store.  
  * **Ожидаемый результат:** Сгенерированный проект Next.js с настроенной структурой папок.
  * *Файлы: вся папка frontend*
  * **Выполнено:** Создана базовая структура проекта Next.js с App Router, настроены основные папки.

* \[x\] **Задача 1.2.2: Настройка Mantine (темизация light/dark, базовые layout-компоненты).**  
  * **Контекст:** Интеграция UI-библиотеки Mantine.  
  * **Тех. указания:**  
    1. Установить Mantine: npm install @mantine/core @mantine/hooks @emotion/react.  
    2. Настроить MantineProvider в корневом layout.tsx (frontend/src/app/layout.tsx).  
    3. Реализовать базовую структуру Layout с Header, Navbar (пока пустые или с заглушками) и основной областью контента.  
    4. Добавить переключатель тем (light/dark) в Header, используя Mantine ColorSchemeProvider и хуки.  
  * **Ожидаемый результат:** Обновленный layout.tsx, компоненты для Header, Navbar, переключатель тем.  
  * *Файлы: frontend/src/app/layout.tsx, frontend/src/components/Layout/Header.tsx (новый), frontend/src/components/Layout/Navbar.tsx (новый)*  
  * **Выполнено:** Установлена и настроена библиотека Mantine с поддержкой темизации в корневом layout.tsx.
* \[x\] **Задача 1.2.3: Реализация страниц входа, регистрации.**  
  * **Контекст:** Создание интерфейса для аутентификации пользователей.  
  * **Тех. указания:**  
    1. Создать страницу входа (frontend/src/app/(auth)/login/page.tsx) с формой (email, пароль).  
    2. Создать страницу регистрации (frontend/src/app/(auth)/register/page.tsx).  
    3. Использовать компоненты Mantine (TextInput, PasswordInput, Button, Paper, Stack) для форм.  
    4. Использовать React Hook Form (npm install react-hook-form @hookform/resolvers yup (или zod)) для управления состоянием форм и валидации.  
    5. Формы должны быть клиентскими компонентами ('use client').  
  * **Ожидаемый результат:** Код для страниц входа и регистрации с формами.  
  * *Файлы: frontend/src/app/(auth)/login/page.tsx, frontend/src/app/(auth)/register/page.tsx, frontend/src/components/Auth/LoginForm.tsx (новый), frontend/src/components/Auth/RegisterForm.tsx (новый)*  
  * **Выполнено:** Созданы страницы входа и регистрации в директории app/(auth).
* \[x\] **Задача 1.2.4: Интеграция с API аутентификации, управление состоянием сессии пользователя.**
  * **Контекст:** Подключение фронтенда к бэкенд API аутентификации.  
  * **Тех. указания:**  
    1. Выбрать и настроить библиотеку для управления состоянием сессии (например, NextAuth.js или кастомное решение с React Context / Zustand). Для MVP можно начать с React Context \+ localStorage для токенов.  
    2. Создать сервисные функции для отправки запросов на эндпоинты /auth/login, /auth/register, /auth/refresh-token (использовать fetch или axios).  
    3. При успешном логине/регистрации сохранять токены (access, refresh) в localStorage и в состоянии приложения.  
    4. Реализовать Provider (например, AuthProvider) который будет предоставлять информацию о пользователе и статусе аутентификации.  
    5. Реализовать защищенные роуты (redirect на /login если пользователь не аутентифицирован) с использованием middleware Next.js или логики в AuthProvider.  
    6. Реализовать автоматическое обновление access-токена с помощью refresh-токена при истечении срока действия access-токена или перед запросами к защищенным API.  
  * **Ожидаемый результат:** Код для AuthProvider, сервисных функций API, обновленные формы логина/регистрации для вызова API, базовая настройка защищенных роутов.  
  * *Файлы: frontend/src/contexts/AuthContext.tsx (новый), frontend/src/services/authService.ts (новый), frontend/src/middleware.ts (если используется)*
  * **Выполнено:** Реализованы сервисные функции для аутентификации в authService.ts, настроен API-клиент с перехватчиками для обновления токенов, создан AuthProvider для управления состоянием аутентификации, настроена защита маршрутов через middleware.

### **Спринт 3-4: Управление Клиентами и Лидами (3-4 недели)**

**Цель спринтов:** Реализовать функционал для управления клиентами и лидами, включая CRUD, импорт/экспорт и базовый поиск.

#### **Backend (NestJS)**

* [x] **Задача 1.3.1: Проектирование и реализация моделей данных для Клиентов и Лидов в Prisma Schema.**  
  * **Контекст:** Определение структуры данных для клиентов и лидов в БД.  
  * **Тех. указания:** Дополнить schema.prisma:  
    * Client: id (uuid), firstName, lastName, middleName (optional), phone (unique), email (optional, unique), source (string, позже может стать enum или связью), status (string, позже enum/связь), notes (string, optional), createdAt, updatedAt. Связь с User (ответственный менеджер, assignedToId, assignedTo). Связь с Partner (если клиент принадлежит партнеру, partnerId, Partner).  
    * Lead: Аналогично Client, но может иметь другие поля/статусы. Для MVP можно объединить с Client и различать полем type: 'LEAD' | 'CLIENT' или отдельным статусом. Решить с разработчиком. Пока предположим, что это одна сущность Contact с полем isLead: Boolean.  
    * Contact: id, firstName, lastName, phone, email, source (enum: PARTNER\_LEAD\_WITH\_HISTORY, PARTNER\_LEAD\_NO\_HISTORY, OWN\_LEAD\_GEN, COLD\_BASE, EXTERNAL\_UPLOAD, PURCHASED\_BASE), statusClient (enum: NEW\_NO\_PROCESSING, PARTNER\_LEAD, AUCTION, NOT\_BOUGHT\_COMPANY\_PROCESSING, ... другие настраиваемые), isLead (boolean), assignedUserId (связь с User), partnerId (связь с User \- Партнер/Франчайзи), history (JSONB для истории изменений), comments (JSONB или отдельная таблица), attachments (JSONB или отдельная таблица для ссылок на Object Storage). createdAt, updatedAt.  
    * Comment: id, text, createdAt, authorId (связь с User), contactId (связь с Contact).  
    * Attachment: id, fileName, filePath (в Object Storage), fileType, uploadedAt, uploaderId (связь с User), contactId (связь с Contact).  
    * Обновить связи в User для assignedContacts, partnerContacts.  
  * **Ожидаемый результат:** Обновленный schema.prisma. Сгенерировать миграцию.  
  * *Файлы: backend/prisma/schema.prisma*  
* \[ x \] **Задача 1.3.2: Разработка API для CRUD операций с Клиентами/Лидами (с учетом RBAC).**  
  * **Контекст:** Предоставление API для управления контактами.  
  * **Тех. указания:**  
    1. Создать ContactsModule, ContactsController, ContactsService.  
    2. Эндпоинты CRUD: GET /contacts, POST /contacts, GET /contacts/:id, PATCH /contacts/:id, DELETE /contacts/:id.  
    3. Реализовать RBAC:  
       * Администратор: полный доступ.  
       * Менеджер: доступ к назначенным ему контактам или всем (в зависимости от настроек).  
       * Партнёр/Франчайзи: доступ только к своим контактам (фильтрация по partnerId).  
       * Сотрудник партнёра: доступ к контактам своего партнёра, с учетом доп. ограничений от партнёра (пока не реализуем детально, но заложить).  
    4. ContactsService должен учитывать partnerId и assignedUserId текущего пользователя (из JWT) при выборке и модификации данных.  
    5. DTO для создания/обновления (CreateContactDto, UpdateContactDto) с валидацией.  
  * **Ожидаемый результат:** Код для модуля Contacts, юнит-тесты для ContactsService.  
  * *Файлы: backend/src/contacts/\*\* (новая папка с модулем)*  
* \[ x \] **Задача 1.3.3: Реализация логики для источников клиентов, статусов.**  
  * **Контекст:** Управление значениями полей "источник" и "статус".  
  * **Тех. указания:**  
    1. В ContactsService обеспечить корректную обработку enum-значений для source и statusClient.  
    2. (Опционально для MVP, но хорошо для будущего) Создать отдельные API эндпоинты для получения возможных значений источников и статусов (например, GET /contacts/sources, GET /contacts/statuses), если они не жестко зашиты в enum, а хранятся в справочнике. Пока можно использовать enum в Prisma.  
  * **Ожидаемый результат:** Обновленный ContactsService.  
* [x] **Задача 1.3.4: API для загрузки/выгрузки клиентов (базовый CSV/Excel).**  
  * **Контекст:** Функционал импорта/экспорта контактов.  
  * **Тех. указания:**  
    1. Эндпоинт POST /contacts/upload-csv (защищенный). Принимает CSV файл.  
    2. Использовать BullMQ (настройка в Этапе 3, пока можно сделать синхронно или отложить асинхронность) для обработки файла в фоне.  
    3. Парсинг CSV (использовать papaparse или аналогичную библиотеку).  
    4. Маппинг колонок CSV на поля Contact. Валидация данных. Создание/обновление контактов.  
    5. Эндпоинт GET /contacts/export-csv (защищенный). Генерирует и отдает CSV файл с контактами (с учетом прав доступа).  
    6. Для Excel можно использовать xlsx библиотеку. Начать с CSV.  
  * **Ожидаемый результат:** Код для эндпоинтов импорта/экспорта, сервисная логика.  
  * *Файлы: backend/src/contacts/contacts.controller.ts, backend/src/contacts/contacts.service.ts*

#### **Frontend (Next.js)**

* [x] **Задача 1.4.1: Разработка интерфейса для просмотра списка клиентов/лидов (TanStack Table с базовой фильтрацией/сортировкой).**  
  * **Контекст:** Отображение списка контактов.  
  * **Тех. указания:**  
    1. Создать страницу /contacts (frontend/src/app/contacts/page.tsx).  
    2. Использовать TanStack Table (npm install @tanstack/react-table) для отображения данных.  
    3. Колонки: ФИО, Телефон, Email, Источник, Статус, Ответственный, Дата создания.  
    4. Реализовать базовую клиентскую сортировку по колонкам.  
    5. Реализовать базовую клиентскую фильтрацию (поиск по текстовым полям).  
    6. Получение данных с бэкенд API /contacts (с пагинацией, если бэкенд поддерживает).  
  * **Ожидаемый результат:** Компонент таблицы контактов, страница списка контактов.  
  * *Файлы: frontend/src/app/contacts/page.tsx, frontend/src/components/Contacts/ContactsTable.tsx (новый)*  
* [x] **Задача 1.4.2: Формы для создания/редактирования клиентов/лидов (React Hook Form \+ Mantine).**  
  * **Контекст:** UI для добавления и изменения контактов.  
  * **Тех. указания:**  
    1. Создать страницу /contacts/new и модальное окно/страницу для редактирования (/contacts/\[id\]/edit).  
    2. Использовать React Hook Form и компоненты Mantine для форм.  
    3. Поля формы должны соответствовать модели Contact.  
    4. Реализовать валидацию полей.  
    5. Интеграция с API POST /contacts и PATCH /contacts/:id.  
  * **Ожидаемый результат:** Компоненты форм, страницы создания/редактирования.  
  * *Файлы: frontend/src/app/contacts/new/page.tsx, frontend/src/app/contacts/\[id\]/edit/page.tsx, frontend/src/components/Contacts/ContactForm.tsx (новый)*  
* [x] **Задача 1.4.3: Отображение истории изменений, комментариев, управление вложениями (интеграция с Object Storage).**  
  * **Контекст:** Дополнительная информация по контакту.  
  * **Тех. указания:**  
    1. На странице просмотра/редактирования контакта (/contacts/\[id\]) добавить секции:  
       * История изменений (пока можно отображать JSON поле history или заглушку).  
       * Комментарии: список комментариев, форма для добавления нового комментария (API POST /contacts/:id/comments).  
       * Вложения: список вложений, форма для загрузки файла (API POST /contacts/:id/attachments).  
    2. Для загрузки файлов: настроить бэкенд для приема файлов (например, с multer) и сохранения в Object Storage (Яндекс.Облако). API должно возвращать путь к файлу. Фронтенд отправляет файл на этот API.  
    3. Для Object Storage: разработчик настроит бакет. ИИ может помочь с генерацией кода для NestJS для загрузки в Yandex Object Storage (используя AWS SDK v3, совместимый с S3).  
  * **Ожидаемый результат:** Обновленная страница просмотра/редактирования контакта, компоненты для комментариев и вложений. Код на бэкенде для загрузки файлов.  
  * *Файлы: frontend/src/app/contacts/\[id\]/page.tsx (новая или доработка edit), backend/src/contacts/contacts.controller.ts, backend/src/contacts/contacts.service.ts, backend/src/files/files.module.ts (новый, для загрузки)*  
* \[ \] **Задача 1.4.4: Интеграция Elasticsearch (начальная).**  
  * **Контекст:** Настройка базового поиска по контактам.  
  * **Тех. указания:**  
    1. На бэкенде: установить Elasticsearch client (@elastic/elasticsearch).  
    2. Создать SearchService в NestJS.  
    3. Реализовать логику индексации контактов в Elasticsearch при их создании/обновлении (можно через события NestJS или прямой вызов).  
    4. Создать API эндпоинт GET /search/contacts?query=... который будет выполнять поиск по Elasticsearch.  
    5. На фронтенде: добавить поле поиска на страницу списка контактов, которое будет вызывать этот API.  
  * **Ожидаемый результат:** Код для SearchService на бэкенде, API для поиска, обновленный интерфейс списка контактов с поиском.  
  * *Файлы: backend/src/search/search.module.ts (новый), backend/src/search/search.service.ts (новый), frontend/src/app/contacts/page.tsx*

### **Спринт 5: Базовое управление Сделками и Воронками (2-3 недели)**

**Цель спринта:** Реализовать основной функционал для управления сделками и воронками продаж.

#### **Backend (NestJS)**

* [x] **Задача 1.5.1: Проектирование и реализация моделей данных для Сделок и Воронок продаж (Prisma Schema).**  
  * **Контекст:** Определение структуры данных для сделок и воронок в БД.  
  * **Тех. указания:** Дополнить schema.prisma:  
    * Pipeline (Воронка): id, name, description (optional), isActive (default: true), createdAt, updatedAt. Связь с PipelineStage.  
    * PipelineStage (Этап воронки): id, name, order (integer, для сортировки), color (optional, string), pipelineId (связь с Pipeline), createdAt, updatedAt. Связь с Deal.  
    * Deal (Сделка): id, title, value (Decimal), expectedCloseDate (optional, DateTime), contactId (связь с Contact), assignedUserId (связь с User), pipelineStageId (связь с PipelineStage), partnerId (связь с User \- Партнер/Франчайзи), history (JSONB), comments (JSONB или отдельная таблица), createdAt, updatedAt.  
  * **Ожидаемый результат:** Обновленный schema.prisma. Сгенерировать миграцию.  
  * *Файлы: backend/prisma/schema.prisma*  
* [x] **Задача 1.5.2: API для CRUD операций со Сделками, привязка к клиентам.**  
  * **Контекст:** Предоставление API для управления сделками.  
  * **Тех. указания:**  
    1. Создать DealsModule, DealsController, DealsService.  
    2. Эндпоинты CRUD для сделок, аналогично контактам, с учетом RBAC (фильтрация по partnerId, assignedUserId).  
    3. При создании сделки обязательна привязка к Contact.  
  * **Ожидаемый результат:** Код для модуля Deals, юнит-тесты для DealsService.  
  * *Файлы: backend/src/modules/deals/\*\* (модуль сделок)*  
* [x] **Задача 1.5.3: API для управления этапами воронок.**  
  * **Контекст:** Предоставление API для управления воронками и их этапами.  
  * **Тех. указания:**  
    1. Создать PipelinesModule, PipelinesController, PipelinesService.  
    2. Эндпоинты CRUD для Pipeline и PipelineStage (для Администратора).  
  * **Ожидаемый результат:** Код для модуля Pipelines.  
  * *Файлы: backend/src/pipelines/\*\* (новая папка с модулем)*

#### **Frontend (Next.js)**

* [x] **Задача 1.6.1: Базовый интерфейс для отображения сделок (список/карточки).**  
  * **Контекст:** UI для просмотра сделок.  
  * **Тех. указания:**  
    1. Создать страницу /deals (frontend/app/(dashboard)/deals/page.tsx).  
    2. Фильтры по статусу, менеджеру, клиенту.  
    3. Фильтрация по воронкам, этапам.  
  * **Ожидаемый результат:** Страница списка сделок.  
  * *Файлы: frontend/app/(dashboard)/deals/page.tsx, frontend/components/Deals/DealsKanbanBoard.tsx*  
* [x] **Задача 1.6.2: Возможность создания/редактирования сделок.**  
  * **Контекст:** UI для добавления и изменения сделок.  
  * **Тех. указания:**  
    1. Форма для создания/редактирования сделки (React Hook Form \+ Mantine).  
    2. Поля: Название, Сумма, Клиент (выбор из существующих), Воронка, Этап.  
    3. Интеграция с API.  
  * **Ожидаемый результат:** Компонент формы сделки.  
  * *Файлы: frontend/components/Deals/DealForm.tsx*  
* [x] **Задача 1.6.3: Начальная реализация канбан-доски (Mantine \+ dnd-kit) для управления этапами сделок.**  
  * **Контекст:** Визуальное представление сделок по этапам воронки.  
  * **Тех. указания:**  
    1. Использовать Mantine для структуры колонок (этапы).  
    2. Использовать dnd-kit (npm install @dnd-kit/core @dnd-kit/sortable) для Drag\&Drop карточек сделок между колонками.  
    3. При перемещении карточки сделки отправлять запрос на бэкенд для обновления этапа сделки (PATCH /deals/:id).  
    4. Отображение сделок в виде карточек на доске.  
  * **Ожидаемый результат:** Компонент канбан-доски для сделок.  
  * *Файлы: frontend/components/Deals/DealsKanbanBoard.tsx, frontend/components/Deals/KanbanColumn.tsx, frontend/components/Deals/DealCard.tsx, frontend/app/(dashboard)/deals/page.tsx*
