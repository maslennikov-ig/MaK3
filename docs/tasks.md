---

## Внутренние документы проекта

- [architecture.md — Архитектура](./architecture.md)
- [infrastructure.md — Инфраструктура](./infrastructure.md)
- [project-structure.md — Структура проекта](./project-structure.md)
- [roadmap.md — Дорожная карта](./roadmap.md)
- [changelog.md — Журнал изменений](./changelog.md)
- [questions-to-tz.md — Вопросы к ТЗ](./questions-to-tz.md)
- [ТЗ_CRM_2025.md — Основное ТЗ](./ТЗ_CRM_2025.md)

---

## **Правила работы с задачами (дополненные)**

* Всегда сначала ищем готовую, поддерживаемую библиотеку или компонент, а не пишем с нуля.
* Предпочитаем использовать самые новые, но стабильные версии библиотек, компонентов и модулей.
* Если возникает проблема с зависимостями, и нет возможности обновить до последних стабильных версий — отказываемся от проблемного модуля и ищем современную альтернативу, а не фиксируем старую зависимость.

* Всегда предлагайте архитектурные улучшения или альтернативные варианты, если это может повысить модульность, читаемость или масштабируемость системы.
* Используйте современные best practices для выбранных технологий (например, Server Components в Next.js, feature/domain-based структура, паттерны NestJS/Prisma).
* При необходимости обращайтесь к официальной документации и используйте Context7 для поиска актуальных решений, ссылайтесь на источники.
* Для задач по безопасности явно указывайте потенциальные риски и способы их минимизации (особенно для аутентификации/авторизации, работы с данными, интеграций).

* Отмечайте выполненные задачи как [x]  
* Запрашивайте одобрение пользователя перед началом следующей фазы.
* Если есть задачи для разработчика, сообщай об этом в чате и жди от него подтверждения выполнения  
* Указывайте измененные файлы рядом с задачей (в комментарии или подпункте).  
* Не отмечайте будущие задачи как выполненные, пока не получите явного запроса.  
* Задачи сгруппированы по фазам разработки. Следуйте порядку.  
* Используйте единообразное именование и структуру при добавлении новых задач.  
* При необходимости добавляйте ссылки на документацию или ресурсы.  
* Если задача заблокирована, четко укажите причину и зависимости.  
* Проверяйте завершенные фазы на полноту перед переходом к следующей.  
* По желанию добавляйте временные метки для отслеживания прогресса.  
* Используйте встроенные комментарии для примечаний или обоснования изменений.  
* **Контекст и Цель:** Каждая задача должна начинаться с краткого описания цели (Что мы хотим достичь?) и контекста (Какая часть системы затрагивается? Какие есть зависимости?).  
* **Ожидаемый Результат (Acceptance Criteria):** Четко определить, что считается успешным выполнением задачи (например, "сгенерирован код модуля X с покрытием тестами Y%", "создана схема БД для Z", "настроен CI/CD пайплайн, который выполняет A, B, C").  
* **Технологические Указания:** Указывать конкретные технологии, библиотеки, версии (если критично), паттерны проектирования, которые ИИ должен использовать.  
* **Примеры (если применимо):** Предоставлять небольшие примеры кода, структуры данных или ожидаемого вывода.  
* **Нефункциональные Требования:** Упоминать релевантные нефункциональные требования (производительность, безопасность, читаемость кода, логирование) для конкретной задачи.  
* **Итеративность:** Для сложных задач предлагать ИИ разбить их на подзадачи или генерировать решение по частям, запрашивая обратную связь.  
* **Формат Вывода:** Указывать желаемый формат вывода (например, "предоставить код в виде файла .ts", "сгенерировать Prisma schema", "предоставить команду для Docker CLI").  
* **Вопросы для Уточнения:** Поощрять ИИ задавать уточняющие вопросы, если задача недостаточно ясна.  
* **Фокус на Безопасности:** Для задач, связанных с данными или аутентификацией, явно указывать на необходимость учета аспектов безопасности (например, "реализовать с учетом защиты от XSS", "использовать параметризованные запросы").  
* **Документирование Кода:** Требовать генерации комментариев к коду (TSDoc/JSDoc) для всех публичных функций и сложной логики.  
* **Генерация Тестов:** Для большинства задач по генерации кода требовать также генерации соответствующих юнит-тестов.  
* **Указание на Файлы:** Просить ИИ указывать, какие файлы были созданы или модифицированы.

## **Этап 0: Подготовка, планирование и настройка (3-4 недели)**

**Цель этапа:** Заложить фундамент для разработки, настроить окружение, финализировать архитектуру и подготовить инструменты.

**Общие задачи для ИИ на этапе:**

* Помощь в анализе ТЗ и генерации вопросов для уточнения.  
* Генерация конфигурационных файлов.  
* Написание скриптов для автоматизации.  
* Генерация базовой структуры проектов.  
* Помощь в проектировании схем БД и API.

### **Задача 0.1: Глубокое изучение ТЗ и "Дополнения к ТЗ для ИИ"**

* \[x\] **Проанализировать ТЗ (файл "ТЗ\_CRM\_2025") (из дорожной карты, раздел 5). Сформировать список из 5-10 ключевых вопросов для разработчика, направленных на уточнение неясных моментов или потенциальных противоречий, особенно в контексте модульности и ролей "Партнёр"/"Франчайзи".**  
  * **Ожидаемый результат:** Список вопросов.  
  * **Фокус:** Понимание требований к MVP, архитектуре каталога компонентов, иерархии прав.
  * **Выполнено:** Создан файл questions-to-tz.md с 20 вопросами по модульности, ролям "Партнёр"/"Франчайзи", техническим аспектам и бизнес-требованиям.

### **Задача 0.2: Настройка инфраструктуры разработки**

* \[ \] **Создание репозитория:** (Задача для разработчика, ИИ может помочь с README.md)  
  * \[x\] **Сгенерировать базовый README.md для проекта MaK CRM.**  
    * **Контекст:** Файл будет в корне репозитория.  
    * **Тех. указания:** Включить разделы: "Описание проекта", "Технологический стек" (взять из дорожной карты), "Настройка окружения (кратко)", "Запуск проекта (локально)".  
    * **Ожидаемый результат:** Текст для README.md.  
    * **Выполнено:** Создан файл README.md с описанием проекта, технологическим стеком, инструкциями по настройке окружения и запуску проекта.
* \[ \] **Настройка базового CI/CD пайплайна (GitHub Actions):**  
  * \[x\] **Сгенерировать workflow-файл для GitHub Actions (.github/workflows/ci.yml).**  
    * **Контекст:** Пайплайн для автоматической проверки кода при push в ветки main и develop, а также для Pull Requests.  
    * **Тех. указания:** Должен включать шаги:  
      1. Checkout кода.  
      2. Настройка Node.js (например, v18.x или v20.x).  
      3. Установка зависимостей (npm ci или yarn install).  
      4. Линтинг (ESLint).  
      5. Форматирование (Prettier \--check).  
      6. Запуск юнит-тестов (команда будет npm test или yarn test, пока можно оставить заглушку или базовую команду).  
      7. (Опционально, но желательно) Сборка Docker-образов для frontend и backend (пока без push в registry).  
    * **Ожидаемый результат:** Содержимое файла ci.yml.  
    * **Фокус:** Раннее обнаружение ошибок, консистентность кода.  
    * **Выполнено:** Создан файл .github/workflows/ci.yml с настройкой CI/CD пайплайна для автоматической проверки кода.
* \[ \] **Настройка локального окружения разработки с Docker Compose:**  
  * \[x\] **Сгенерировать файл docker-compose.yml для локальной разработки.**  
    * **Контекст:** Обеспечить запуск всех необходимых сервисов одной командой.  
    * **Тех. указания:** Включить сервисы:  
      1. frontend (Next.js, пока можно использовать базовый образ node и команду для запуска dev-сервера, позже доработаем Dockerfile).  
      2. backend (NestJS, аналогично frontend).  
      3. postgres (официальный образ PostgreSQL, указать версию, например 15 или 16). Настроить тома (volumes) для сохранения данных (./.pgdata:/var/lib/postgresql/data). Задать переменные окружения для пользователя, пароля, имени БД (например, POSTGRES\_USER, POSTGRES\_PASSWORD, POSTGRES\_DB).  
      4. redis (официальный образ Redis, указать версию). Настроить тома для данных.  
      5. elasticsearch (официальный образ Elasticsearch, указать версию). Настроить тома, переменные окружения (например, discovery.type=single-node, настройки для разработки).  
    * **Ожидаемый результат:** Содержимое файла docker-compose.yml.  
    * **Дополнительно:** Сгенерировать пример файла .env для docker-compose.yml с необходимыми переменными.  
    * **Выполнено:** Создан файл docker-compose.yml с настройкой всех необходимых сервисов и файл .env с переменными окружения.
* \[x\] **Подготовка базовой инфраструктуры в Яндекс.Облаке (или выбранном провайдере):** (Больше задача для разработчика, ИИ может помочь со скриптами)  
  * \[x\] **Сгенерировать пример Terraform-конфигурации (или Ansible playbook, или Yandex Cloud CLI скрипт) для создания управляемой инстанса PostgreSQL в Яндекс.Облаке.**  
    * **Контекст:** Подготовка к будущим развертываниям.  
    * **Тех. указания:** Включить базовые параметры: тип инстанса, размер диска, регион, настройки сети (для примера). Указать на необходимость безопасного управления кредами.  
    * **Ожидаемый результат:** Пример кода для выбранного инструмента IaC.  
    * **Выполнено:** Создан файл infrastructure/terraform/yandex-cloud/main.tf с Terraform-конфигурацией для создания управляемой инстанса PostgreSQL в Яндекс.Облаке.

### **Задача 0.3: Детализация архитектуры и начальное проектирование**

* \[ \] **Финализация высокоуровневой технической архитектуры:** (Разработчик \+ ИИ для генерации диаграмм/документации)  
  * \[ \] **На основе ТЗ и дорожной карты, сгенерировать текстовое описание и диаграмму (в формате Mermaid.js или PlantUML) для архитектуры C4 Model: Уровень 1 (System Context) и Уровень 2 (Containers).**  
    * **Контекст:** Визуализация основных компонентов системы и их взаимодействий.  
    * **Тех. указания:** Учесть Frontend, Backend, Базы данных (PostgreSQL, Redis, Elasticsearch), Object Storage, Очереди (BullMQ), Внешние интеграции (AmoCRM, Telegram).  
    * **Ожидаемый результат:** Текстовое описание и код для генерации диаграмм.  
* \[ \] **Проектирование системы с учетом будущей архитектуры "Каталога компонентов":**  
  * \[ \] **Предложить 2-3 варианта базовой структуры модулей для NestJS (backend) и Next.js (frontend), которые облегчат последующее выделение функциональности в независимые компоненты/модули каталога.**  
    * **Контекст:** Заложить основу для модульности.  
    * **Тех. указания:** Рассмотреть feature-based структуру, domain-based структуру. Для NestJS – использование модулей NestJS. Для Next.js – организация папок в app router.  
    * **Ожидаемый результат:** Описание вариантов структуры с примерами иерархии папок.  
* \[x\] **Проектирование схемы основной БД (PostgreSQL) с использованием Prisma Schema:**  
  * \[x\] **Сгенерировать начальную Prisma schema (schema.prisma) для сущностей: User, Role, Permission.**  
    * **Контекст:** Основа для аутентификации и авторизации.  
    * **Тех. указания:**  
      * User: id (uuid, default: uuid()), email (unique), passwordHash, firstName, lastName, isActive (boolean, default: true), createdAt, updatedAt. Связь с Role.  
      * Role: id (uuid), name (unique, enum: ADMIN, MANAGER, BROKER, PARTNER, FRANCHISEE, PARTNER\_EMPLOYEE), description. Связь с User (many-to-many или one-to-many если у юзера одна роль). Связь с Permission (many-to-many).  
      * Permission: id (uuid), action (string, e.g., create:client, read:deal), subject (string, e.g., client, deal).  
      * Использовать @default(now()) и @updatedAt.  
      * Указать datasource db { provider \= "postgresql", url \= env("DATABASE\_URL") } и generator client { provider \= "prisma-client-js" }.  
    * **Ожидаемый результат:** Содержимое файла schema.prisma.  
    * **Фокус:** Безопасность (не хранить пароли в открытом виде), гибкость RBAC.  
    * **Выполнено:** Создан файл backend/prisma/schema.prisma с определением всех необходимых моделей и связей между ними.
  * \[ \] **Сгенерировать команду для создания начальной миграции Prisma на основе созданной схемы.**  
    * **Ожидаемый результат:** Команда CLI (например, npx prisma migrate dev \--name init\_users\_roles).  
* \[ \] **Проектирование базовых API эндпоинтов (OpenAPI/Swagger спецификации):**  
  * \[ \] **Сгенерировать OpenAPI (v3) спецификацию в формате YAML для модуля аутентификации.**  
    * **Контекст:** Описание API для регистрации, входа, выхода, обновления токена.  
    * **Тех. указания:** Эндпоинты:  
      * POST /auth/register (RequestBody: email, password, firstName, lastName; Response: User info, accessToken, refreshToken)  
      * POST /auth/login (RequestBody: email, password; Response: User info, accessToken, refreshToken)  
      * POST /auth/logout (защищенный, использует refreshToken)  
      * POST /auth/refresh-token (RequestBody: refreshToken; Response: accessToken, refreshToken)  
      * Определить DTO для запросов и ответов, включая примеры. Указать коды ответов (200, 201, 400, 401, 403).  
    * **Ожидаемый результат:** Содержимое YAML файла спецификации.  
* \[ \] **Планирование структуры модулей для NestJS и Next.js:** (частично покрыто выше)  
  * \[ \] **Для NestJS: предложить структуру для модуля AuthModule, включая контроллер, сервис, DTOs, guards, strategies (JWT).**  
    * **Ожидаемый результат:** Иерархия папок и файлов с кратким описанием назначения каждого.  
  * \[ \] **Для Next.js: предложить структуру для страниц аутентификации (/login, /register) в app router, включая использование Server Components и Client Components для форм.**  
    * **Ожидаемый результат:** Иерархия папок и файлов.

### **Задача 0.4: Выбор и настройка инструментов**

* \[ \] **Настройка IDE:** (Задача разработчика)  
* \[ \] **Настройка ESLint, Prettier:**  
  * \[x\] **Сгенерировать конфигурационные файлы для ESLint (.eslintrc.js или .json) и Prettier (.prettierrc.js или .json, .prettierignore).**  
    * **Контекст:** Обеспечение единого стиля кода и отлов ошибок.  
    * **Тех. указания:**  
      * ESLint: для TypeScript, React (если фронтенд), NestJS (если бэкенд). Включить рекомендуемые правила, плагины (например, @typescript-eslint/eslint-plugin, eslint-plugin-react, eslint-plugin-prettier).  
      * Prettier: базовые настройки (tabWidth, semi, singleQuote и т.д.).  
    * **Ожидаемый результат:** Содержимое конфигурационных файлов.  
    * **Выполнено:** Созданы конфигурационные файлы .eslintrc.json и .prettierrc для frontend и backend, а также файлы .prettierignore.
  * \[x\] **Сгенерировать команды npm/yarn для установки ESLint, Prettier и их зависимостей в package.json (dev-зависимости).**  
    * **Ожидаемый результат:** Список команд.  
    * **Выполнено:** Добавлены все необходимые зависимости в package.json для frontend и backend.
  * \[x\] **Добавить скрипты lint и format в package.json.**  
    * **Ожидаемый результат:** Фрагмент для package.json.  
    * **Выполнено:** Добавлены скрипты lint, format и format:check в package.json для frontend и backend.
* \[ \] **Выбор и первичная настройка системы управления проектом/задачами:** (Задача разработчика)

## **Этап 1: Базовая CRM – Ядро и Пользователи (MVP Часть 1\) (8-10 недель)**

**Цель этапа:** Реализовать основной функционал CRM, включая управление пользователями, клиентами, лидами и сделками.

### **Спринт 1-2: Ядро Backend и Аутентификация (3-4 недели)**

**Цель спринтов:** Создать работающее ядро бэкенда с системой аутентификации и базовой авторизацией, а также настроить фронтенд для взаимодействия с ним.

#### **Backend (NestJS)**

* \[ \] **Задача 1.1.1: Создание базовой структуры проекта NestJS.**  
  * **Контекст:** Инициализация нового NestJS проекта.  
  * **Тех. указания:** Использовать Nest CLI: nest new backend \--package-manager npm (или yarn/pnpm).  
  * **Ожидаемый результат:** Сгенерированный проект NestJS. 
  * *Файлы: вся папка backend*  
* \[ \] **Задача 1.1.2: Настройка Prisma ORM и подключение к PostgreSQL.**  
  * **Контекст:** Интеграция Prisma для взаимодействия с БД.  
  * **Тех. указания:**  
    1. Установить Prisma CLI и Prisma Client: npm install prisma \--save-dev, npm install @prisma/client.  
    2. Инициализировать Prisma: npx prisma init \--datasource-provider postgresql. (ИИ предоставляет команды)  
    3. Обновить .env файл в backend с DATABASE\_URL (пример: postgresql://user:password@localhost:5432/makcrm\_dev?schema=public).  
    4. Создать PrismaService в NestJS (src/prisma/prisma.service.ts) который инкапсулирует PrismaClient и обрабатывает подключение/отключение.  
    5. Зарегистрировать PrismaModule (создать src/prisma/prisma.module.ts) и импортировать его глобально в AppModule.  
  * **Ожидаемый результат:** Код для PrismaService, PrismaModule, обновленный AppModule. Команды для CLI.  
  * *Файлы: backend/prisma/schema.prisma (уже есть из Этапа 0), backend/.env, backend/src/prisma/prisma.service.ts, backend/src/prisma/prisma.module.ts, backend/src/app.module.ts*  
* \[ \] **Задача 1.1.3: Реализация базовой конфигурации (переменные окружения).**  
  * **Контекст:** Управление конфигурацией приложения через переменные окружения.  
  * **Тех. указания:**  
    1. Использовать @nestjs/config. Установить: npm install @nestjs/config.  
    2. Настроить ConfigModule в AppModule (ConfigModule.forRoot({ isGlobal: true })).  
    3. Определить переменные окружения для JWT секрета, срока жизни токенов, порта приложения в .env.  
    4. Создать файл валидации для переменных окружения с использованием Joi или class-validator.  
  * **Ожидаемый результат:** Обновленный AppModule, пример .env с новыми переменными, код для валидации конфигурации.  
  * *Файлы: backend/src/app.module.ts, backend/.env, backend/src/config/env.validation.ts (новый)*  
* \[ \] **Задача 1.1.4: Настройка логирования (интеграция с Sentry на базовом уровне).**  
  * **Контекст:** Отслеживание ошибок и событий в приложении.  
  * **Тех. указания:**  
    1. Установить Sentry SDK для NestJS: npm install \--save @sentry/node @sentry/profiling-node.  
    2. Инициализировать Sentry в main.ts с DSN из переменной окружения.  
    3. Настроить базовый SentryInterceptor для автоматического отлова исключений.  
    4. Добавить пример логирования кастомного события с помощью Sentry.  
  * **Ожидаемый результат:** Обновленный main.ts, код для SentryInterceptor, пример использования.  
  * *Файлы: backend/src/main.ts, backend/src/sentry.interceptor.ts (новый)*  
* \[ \] **Задача 1.1.5: Реализация JWT аутентификации (регистрация, вход, выход, обновление токена).**  
  * **Контекст:** Обеспечение безопасного доступа к системе.  
  * **Тех. указания:**  
    1. Создать AuthModule (src/auth/auth.module.ts).  
    2. Создать AuthController (src/auth/auth.controller.ts) с эндпоинтами из OpenAPI спецификации (Задача 0.3).  
    3. Создать AuthService (src/auth/auth.service.ts) с логикой:  
       * Регистрация: хеширование пароля (использовать bcrypt), сохранение пользователя в БД через PrismaService.  
       * Вход: проверка пользователя, сравнение хеша пароля, генерация access и refresh токенов.  
       * Выход: (если токены хранятся на бэкенде для аннулирования, если нет \- задача для фронтенда удалить токены). Для простоты MVP, можно пока не реализовывать отзыв токенов на бэкенде.  
       * Обновление токена: проверка refresh токена, генерация новой пары токенов.  
    4. Использовать @nestjs/jwt для генерации и проверки токенов. Настроить JwtModule в AuthModule (секрет, срок жизни из ConfigService).  
    5. Создать DTO для запросов (RegisterUserDto, LoginUserDto, RefreshTokenDto) и ответов (AuthResponseDto) с валидацией (class-validator).  
    6. Создать JwtStrategy (src/auth/strategies/jwt.strategy.ts) и JwtAuthGuard (src/auth/guards/jwt-auth.guard.ts).  
    7. Создать LocalStrategy (src/auth/strategies/local.strategy.ts) и LocalAuthGuard (src/auth/guards/local-auth.guard.ts) для эндпоинта входа.  
  * **Ожидаемый результат:** Код для AuthModule, AuthController, AuthService, DTOs, JwtStrategy, LocalStrategy, JwtAuthGuard, LocalAuthGuard. Юнит-тесты для AuthService.  
  * *Файлы: backend/src/auth/\*\* (новая папка с модулем)*  
* \[ \] **Задача 1.1.6: Создание базовых сущностей для Пользователей и Ролей (Prisma Schema уже есть). Реализация RBAC (гарды, декораторы) \- основа.**  
  * **Контекст:** Управление доступом на основе ролей.  
  * **Тех. указания:**  
    1. Создать RolesGuard (src/auth/guards/roles.guard.ts).  
    2. Создать декоратор @Roles(...roles: Role\[\]) (src/auth/decorators/roles.decorator.ts) для указания разрешенных ролей на эндпоинтах.  
    3. В AuthService или отдельном UserService реализовать методы для назначения ролей пользователям (пока можно хардкодить при создании или через Prisma Studio).  
    4. Доработать JwtStrategy для включения ролей пользователя в payload токена или загрузки их при валидации.  
    5. Продумать механизм иерархии прав (Партнёры/Франчайзи управляют правами своих сотрудников). На этом этапе достаточно заложить основу: при проверке прав в RolesGuard учитывать, что PARTNER может управлять PARTNER\_EMPLOYEE.  
  * **Ожидаемый результат:** Код для RolesGuard, @Roles декоратора, обновленный JwtStrategy.  
  * *Файлы: backend/src/auth/guards/roles.guard.ts, backend/src/auth/decorators/roles.decorator.ts, backend/src/auth/strategies/jwt.strategy.ts*  
* \[ \] **Задача 1.1.7: Разработка API для управления пользователями (CRUD для администратора).**  
  * **Контекст:** Предоставление администратору возможности управлять пользователями.  
  * **Тех. указания:**  
    1. Создать UsersModule (src/users/users.module.ts).  
    2. Создать UsersController (src/users/users.controller.ts) с эндпоинтами:  
       * GET /users (список пользователей, с пагинацией, защищено JwtAuthGuard и @Roles('ADMIN')).  
       * POST /users (создание пользователя, @Roles('ADMIN')). Администратор назначает роль при создании (включая "Партнёр", "Франчайзи").  
       * GET /users/:id (получение пользователя по ID, @Roles('ADMIN')).  
       * PATCH /users/:id (обновление пользователя, @Roles('ADMIN')).  
       * DELETE /users/:id (удаление пользователя, @Roles('ADMIN')).  
    3. Создать UsersService (src/users/users.service.ts) с бизнес-логикой CRUD, используя PrismaService.  
    4. Создать DTO для создания (CreateUserDto) и обновления (UpdateUserDto) пользователя с валидацией. CreateUserDto должен включать поле для назначения роли.  
  * **Ожидаемый результат:** Код для UsersModule, UsersController, UsersService, DTOs. Юнит-тесты для UsersService.  
  * *Файлы: backend/src/users/\*\* (новая папка с модулем)*

#### **Frontend (Next.js)**

* \[ \] **Задача 1.2.1: Создание базовой структуры проекта Next.js с App Router.**  
  * **Контекст:** Инициализация нового Next.js проекта.  
  * **Тех. указания:** Использовать команду: npx create-next-app@latest frontend \--typescript \--tailwind \--eslint \--app.  
  * **Ожидаемый результат:** Сгенерированный проект Next.js. 
  * *Файлы: вся папка frontend*  
* \[ \] **Задача 1.2.2: Настройка Mantine (темизация light/dark, базовые layout-компоненты).**  
  * **Контекст:** Интеграция UI-библиотеки Mantine.  
  * **Тех. указания:**  
    1. Установить Mantine: npm install @mantine/core @mantine/hooks @emotion/react.  
    2. Настроить MantineProvider в корневом layout.tsx (frontend/src/app/layout.tsx).  
    3. Реализовать базовую структуру Layout с Header, Navbar (пока пустые или с заглушками) и основной областью контента.  
    4. Добавить переключатель тем (light/dark) в Header, используя Mantine ColorSchemeProvider и хуки.  
  * **Ожидаемый результат:** Обновленный layout.tsx, компоненты для Header, Navbar, переключатель тем.  
  * *Файлы: frontend/src/app/layout.tsx, frontend/src/components/Layout/Header.tsx (новый), frontend/src/components/Layout/Navbar.tsx (новый)*  
* \[ \] **Задача 1.2.3: Реализация страниц входа, регистрации.**  
  * **Контекст:** Создание UI для аутентификации пользователей.  
  * **Тех. указания:**  
    1. Создать страницы (route.tsx и page.tsx) для /login и /register в frontend/src/app/.  
    2. Использовать компоненты Mantine (TextInput, PasswordInput, Button, Paper, Stack) для форм.  
    3. Использовать React Hook Form (npm install react-hook-form @hookform/resolvers yup (или zod)) для управления состоянием форм и валидации.  
    4. Формы должны быть клиентскими компонентами ('use client').  
  * **Ожидаемый результат:** Код для страниц входа и регистрации с формами.  
  * *Файлы: frontend/src/app/login/page.tsx, frontend/src/app/register/page.tsx, frontend/src/components/Auth/LoginForm.tsx (новый), frontend/src/components/Auth/RegisterForm.tsx (новый)*  
* \[ \] **Задача 1.2.4: Интеграция с API аутентификации, управление состоянием сессии пользователя.**  
  * **Контекст:** Подключение фронтенда к бэкенд API аутентификации.  
  * **Тех. указания:**  
    1. Выбрать и настроить библиотеку для управления состоянием сессии (например, NextAuth.js или кастомное решение с React Context / Zustand). Для MVP можно начать с React Context \+ localStorage для токенов.  
    2. Создать сервисные функции для отправки запросов на эндпоинты /auth/login, /auth/register, /auth/refresh-token (использовать fetch или axios).  
    3. При успешном логине/регистрации сохранять токены (access, refresh) в localStorage и в состоянии приложения.  
    4. Реализовать Provider (например, AuthProvider) который будет предоставлять информацию о пользователе и статусе аутентификации.  
    5. Реализовать защищенные роуты (redirect на /login если пользователь не аутентифицирован) с использованием middleware Next.js или логики в AuthProvider.  
    6. Реализовать автоматическое обновление access-токена с помощью refresh-токена при истечении срока действия access-токена или перед запросами к защищенным API.  
  * **Ожидаемый результат:** Код для AuthProvider, сервисных функций API, обновленные формы логина/регистрации для вызова API, базовая настройка защищенных роутов.  
  * *Файлы: frontend/src/contexts/AuthContext.tsx (новый), frontend/src/services/authService.ts (новый), frontend/src/middleware.ts (если используется)*

### **Спринт 3-4: Управление Клиентами и Лидами (3-4 недели)**

**Цель спринтов:** Реализовать функционал для управления клиентами и лидами, включая CRUD, импорт/экспорт и базовый поиск.

#### **Backend (NestJS)**

* \[ \] **Задача 1.3.1: Проектирование и реализация моделей данных для Клиентов и Лидов (Prisma Schema).**  
  * **Контекст:** Определение структуры данных для клиентов и лидов в БД.  
  * **Тех. указания:** Дополнить schema.prisma:  
    * Client: id (uuid), firstName, lastName, middleName (optional), phone (unique), email (optional, unique), source (string, позже может стать enum или связью), status (string, позже enum/связь), notes (string, optional), createdAt, updatedAt. Связь с User (ответственный менеджер, assignedToId, assignedTo). Связь с Partner (если клиент принадлежит партнеру, partnerId, Partner).  
    * Lead: Аналогично Client, но может иметь другие поля/статусы. Для MVP можно объединить с Client и различать полем type: 'LEAD' | 'CLIENT' или отдельным статусом. Решить с разработчиком. Пока предположим, что это одна сущность Contact с полем isLead: Boolean.  
    * Contact: id, firstName, lastName, phone, email, source (enum: PARTNER\_LEAD\_WITH\_HISTORY, PARTNER\_LEAD\_NO\_HISTORY, OWN\_LEAD\_GEN, COLD\_BASE, EXTERNAL\_UPLOAD, PURCHASED\_BASE), statusClient (enum: NEW\_NO\_PROCESSING, PARTNER\_LEAD, AUCTION, NOT\_BOUGHT\_COMPANY\_PROCESSING, ... другие настраиваемые), isLead (boolean), assignedUserId (связь с User), partnerId (связь с User \- Партнер/Франчайзи), history (JSONB для истории изменений), comments (JSONB или отдельная таблица), attachments (JSONB или отдельная таблица для ссылок на Object Storage). createdAt, updatedAt.  
    * Comment: id, text, createdAt, authorId (связь с User), contactId (связь с Contact).  
    * Attachment: id, fileName, filePath (в Object Storage), fileType, uploadedAt, uploaderId (связь с User), contactId (связь с Contact).  
    * Обновить связи в User для assignedContacts, partnerContacts.  
  * **Ожидаемый результат:** Обновленный schema.prisma. Сгенерировать миграцию.  
  * *Файлы: backend/prisma/schema.prisma*  
* \[ \] **Задача 1.3.2: Разработка API для CRUD операций с Клиентами/Лидами (с учетом RBAC).**  
  * **Контекст:** Предоставление API для управления контактами.  
  * **Тех. указания:**  
    1. Создать ContactsModule, ContactsController, ContactsService.  
    2. Эндпоинты CRUD: GET /contacts, POST /contacts, GET /contacts/:id, PATCH /contacts/:id, DELETE /contacts/:id.  
    3. Реализовать RBAC:  
       * Администратор: полный доступ.  
       * Менеджер: доступ к назначенным ему контактам или всем (в зависимости от настроек).  
       * Партнёр/Франчайзи: доступ только к своим контактам (фильтрация по partnerId).  
       * Сотрудник партнёра: доступ к контактам своего партнёра, с учетом доп. ограничений от партнёра (пока не реализуем детально, но заложить).  
    4. ContactsService должен учитывать partnerId и assignedUserId текущего пользователя (из JWT) при выборке и модификации данных.  
    5. DTO для создания/обновления (CreateContactDto, UpdateContactDto) с валидацией.  
  * **Ожидаемый результат:** Код для модуля Contacts, юнит-тесты для ContactsService.  
  * *Файлы: backend/src/contacts/\*\* (новая папка с модулем)*  
* \[ \] **Задача 1.3.3: Реализация логики для источников клиентов, статусов.**  
  * **Контекст:** Управление значениями полей "источник" и "статус".  
  * **Тех. указания:**  
    1. В ContactsService обеспечить корректную обработку enum-значений для source и statusClient.  
    2. (Опционально для MVP, но хорошо для будущего) Создать отдельные API эндпоинты для получения возможных значений источников и статусов (например, GET /contacts/sources, GET /contacts/statuses), если они не жестко зашиты в enum, а хранятся в справочнике. Пока можно использовать enum в Prisma.  
  * **Ожидаемый результат:** Обновленный ContactsService.  
* \[ \] **Задача 1.3.4: API для загрузки/выгрузки клиентов (базовый CSV/Excel).**  
  * **Контекст:** Функционал импорта/экспорта контактов.  
  * **Тех. указания:**  
    1. Эндпоинт POST /contacts/upload-csv (защищенный). Принимает CSV файл.  
    2. Использовать BullMQ (настройка в Этапе 3, пока можно сделать синхронно или отложить асинхронность) для обработки файла в фоне.  
    3. Парсинг CSV (использовать papaparse или аналогичную библиотеку).  
    4. Маппинг колонок CSV на поля Contact. Валидация данных. Создание/обновление контактов.  
    5. Эндпоинт GET /contacts/export-csv (защищенный). Генерирует и отдает CSV файл с контактами (с учетом прав доступа).  
    6. Для Excel можно использовать xlsx библиотеку. Начать с CSV.  
  * **Ожидаемый результат:** Код для эндпоинтов импорта/экспорта, сервисная логика.  
  * *Файлы: backend/src/contacts/contacts.controller.ts, backend/src/contacts/contacts.service.ts*

#### **Frontend (Next.js)**

* \[ \] **Задача 1.4.1: Разработка интерфейса для просмотра списка клиентов/лидов (TanStack Table с базовой фильтрацией/сортировкой).**  
  * **Контекст:** Отображение списка контактов.  
  * **Тех. указания:**  
    1. Создать страницу /contacts (frontend/src/app/contacts/page.tsx).  
    2. Использовать TanStack Table (npm install @tanstack/react-table) для отображения данных.  
    3. Колонки: ФИО, Телефон, Email, Источник, Статус, Ответственный, Дата создания.  
    4. Реализовать базовую клиентскую сортировку по колонкам.  
    5. Реализовать базовую клиентскую фильтрацию (поиск по текстовым полям).  
    6. Получение данных с бэкенд API /contacts (с пагинацией, если бэкенд поддерживает).  
  * **Ожидаемый результат:** Компонент таблицы контактов, страница списка контактов.  
  * *Файлы: frontend/src/app/contacts/page.tsx, frontend/src/components/Contacts/ContactsTable.tsx (новый)*  
* \[ \] **Задача 1.4.2: Формы для создания/редактирования клиентов/лидов (React Hook Form \+ Mantine).**  
  * **Контекст:** UI для добавления и изменения контактов.  
  * **Тех. указания:**  
    1. Создать страницу /contacts/new и модальное окно/страницу для редактирования (/contacts/\[id\]/edit).  
    2. Использовать React Hook Form и компоненты Mantine для форм.  
    3. Поля формы должны соответствовать модели Contact.  
    4. Реализовать валидацию полей.  
    5. Интеграция с API POST /contacts и PATCH /contacts/:id.  
  * **Ожидаемый результат:** Компоненты форм, страницы создания/редактирования.  
  * *Файлы: frontend/src/app/contacts/new/page.tsx, frontend/src/app/contacts/\[id\]/edit/page.tsx, frontend/src/components/Contacts/ContactForm.tsx (новый)*  
* \[ \] **Задача 1.4.3: Отображение истории изменений, комментариев, управление вложениями (интеграция с Object Storage).**  
  * **Контекст:** Дополнительная информация по контакту.  
  * **Тех. указания:**  
    1. На странице просмотра/редактирования контакта (/contacts/\[id\]) добавить секции:  
       * История изменений (пока можно отображать JSON поле history или заглушку).  
       * Комментарии: список комментариев, форма для добавления нового комментария (API POST /contacts/:id/comments).  
       * Вложения: список вложений, форма для загрузки файла (API POST /contacts/:id/attachments).  
    2. Для загрузки файлов: настроить бэкенд для приема файлов (например, с multer) и сохранения в Object Storage (Яндекс.Облако). API должно возвращать путь к файлу. Фронтенд отправляет файл на этот API.  
    3. Для Object Storage: разработчик настроит бакет. ИИ может помочь с генерацией кода для NestJS для загрузки в Yandex Object Storage (используя AWS SDK v3, совместимый с S3).  
  * **Ожидаемый результат:** Обновленная страница просмотра/редактирования контакта, компоненты для комментариев и вложений. Код на бэкенде для загрузки файлов.  
  * *Файлы: frontend/src/app/contacts/\[id\]/page.tsx (новая или доработка edit), backend/src/contacts/contacts.controller.ts, backend/src/contacts/contacts.service.ts, backend/src/files/files.module.ts (новый, для загрузки)*  
* \[ \] **Задача 1.4.4: Интеграция Elasticsearch (начальная).**  
  * **Контекст:** Настройка базового поиска по контактам.  
  * **Тех. указания:**  
    1. На бэкенде: установить Elasticsearch client (@elastic/elasticsearch).  
    2. Создать SearchService в NestJS.  
    3. Реализовать логику индексации контактов в Elasticsearch при их создании/обновлении (можно через события NestJS или прямой вызов).  
    4. Создать API эндпоинт GET /search/contacts?query=... который будет выполнять поиск по Elasticsearch.  
    5. На фронтенде: добавить поле поиска на страницу списка контактов, которое будет вызывать этот API.  
  * **Ожидаемый результат:** Код для SearchService на бэкенде, API для поиска, обновленный интерфейс списка контактов с поиском.  
  * *Файлы: backend/src/search/search.module.ts (новый), backend/src/search/search.service.ts (новый), frontend/src/app/contacts/page.tsx*

### **Спринт 5: Базовое управление Сделками и Воронками (2-3 недели)**

**Цель спринта:** Реализовать основной функционал для управления сделками и воронками продаж.

#### **Backend (NestJS)**

* \[ \] **Задача 1.5.1: Проектирование и реализация моделей данных для Сделок и Воронок продаж (Prisma Schema).**  
  * **Контекст:** Определение структуры данных для сделок и воронок в БД.  
  * **Тех. указания:** Дополнить schema.prisma:  
    * Pipeline (Воронка): id, name, description (optional), isActive (default: true), createdAt, updatedAt. Связь с PipelineStage.  
    * PipelineStage (Этап воронки): id, name, order (integer, для сортировки), color (optional, string), pipelineId (связь с Pipeline), createdAt, updatedAt. Связь с Deal.  
    * Deal (Сделка): id, title, value (Decimal), expectedCloseDate (optional, DateTime), contactId (связь с Contact), assignedUserId (связь с User), pipelineStageId (связь с PipelineStage), partnerId (связь с User \- Партнер/Франчайзи), history (JSONB), comments (JSONB или отдельная таблица), createdAt, updatedAt.  
  * **Ожидаемый результат:** Обновленный schema.prisma. Сгенерировать миграцию.  
  * *Файлы: backend/prisma/schema.prisma*  
* \[ \] **Задача 1.5.2: API для CRUD операций со Сделками, привязка к клиентам.**  
  * **Контекст:** Предоставление API для управления сделками.  
  * **Тех. указания:**  
    1. Создать DealsModule, DealsController, DealsService.  
    2. Эндпоинты CRUD для сделок, аналогично контактам, с учетом RBAC (фильтрация по partnerId, assignedUserId).  
    3. При создании сделки обязательна привязка к Contact.  
  * **Ожидаемый результат:** Код для модуля Deals, юнит-тесты для DealsService.  
  * *Файлы: backend/src/deals/\*\* (новая папка с модулем)*  
* \[ \] **Задача 1.5.3: API для управления этапами воронок.**  
  * **Контекст:** Предоставление API для управления воронками и их этапами.  
  * **Тех. указания:**  
    1. Создать PipelinesModule, PipelinesController, PipelinesService.  
    2. Эндпоинты CRUD для Pipeline и PipelineStage (для Администратора).  
  * **Ожидаемый результат:** Код для модуля Pipelines.  
  * *Файлы: backend/src/pipelines/\*\* (новая папка с модулем)*

#### **Frontend (Next.js)**

* \[ \] **Задача 1.6.1: Базовый интерфейс для отображения сделок (список/карточки).**  
  * **Контекст:** UI для просмотра сделок.  
  * **Тех. указания:**  
    1. Создать страницу /deals (frontend/src/app/deals/page.tsx).  
    2. Отображение сделок в виде списка (TanStack Table) или карточек.  
    3. Фильтрация по воронкам, этапам.  
  * **Ожидаемый результат:** Страница списка сделок.  
  * *Файлы: frontend/src/app/deals/page.tsx, frontend/src/components/Deals/DealsList.tsx (новый) или DealsKanban.tsx (новый)*  
* \[ \] **Задача 1.6.2: Возможность создания/редактирования сделок.**  
  * **Контекст:** UI для добавления и изменения сделок.  
  * **Тех. указания:**  
    1. Форма для создания/редактирования сделки (React Hook Form \+ Mantine).  
    2. Поля: Название, Сумма, Клиент (выбор из существующих), Воронка, Этап.  
    3. Интеграция с API.  
  * **Ожидаемый результат:** Компонент формы сделки.  
  * *Файлы: frontend/src/components/Deals/DealForm.tsx (новый)*  
* \[ \] **Задача 1.6.3: Начальная реализация канбан-доски (Mantine \+ dnd-kit) для управления этапами сделок.**  
  * **Контекст:** Визуальное представление сделок по этапам воронки.  
  * **Тех. указания:**  
    1. Использовать Mantine для структуры колонок (этапы).  
    2. Использовать dnd-kit (npm install @dnd-kit/core @dnd-kit/sortable) для Drag\&Drop карточек сделок между колонками.  
    3. При перемещении карточки сделки отправлять запрос на бэкенд для обновления этапа сделки (PATCH /deals/:id).  
    4. Отображение сделок в виде карточек на доске.  
  * **Ожидаемый результат:** Компонент канбан-доски для сделок.  
  * *Файлы: frontend/src/components/Deals/DealsKanbanBoard.tsx (новый), возможно обновление frontend/src/app/deals/page.tsx*

## **Этап 2: Ключевые Интеграции и Единый Кабинет для Внешних Пользователей (MVP Часть 2\) (8-10 недель)**

**Цель этапа:** Интегрировать систему с AmoCRM, разработать Telegram-бота и создать основу Единого Кабинета для Партнёров и Франчайзи.

### **Спринт 6-7: Интеграция с AmoCRM (3-4 недели)**

**Цель спринтов:** Реализовать двустороннюю синхронизацию данных с AmoCRM.

#### **Backend (NestJS)**

* \[ \] **Задача 2.1.1: Глубокий анализ API AmoCRM, определение сценариев двусторонней интеграции.**  
  * **Контекст:** Понимание возможностей API AmoCRM и требований ТЗ (2.6).  
  * **Тех. указания:** ИИ может помочь найти документацию по API AmoCRM, примеры использования, ограничения. Разработчик определяет сценарии.  
  * **Ожидаемый результат:** Краткий документ (или комментарии в коде) с описанием полей для маппинга (Клиенты, Сделки, Статусы) и логики синхронизации (триггеры, частота).  
* \[ \] **Задача 2.1.2: Разработка модуля интеграции: маппинг полей, логика синхронизации.**  
  * **Контекст:** Создание сервиса для взаимодействия с AmoCRM.  
  * **Тех. указания:**  
    1. Создать AmoCRModule, AmoCRMService.  
    2. Реализовать методы для:  
       * Аутентификации в AmoCRM (OAuth 2.0 или API ключ, в зависимости от их API). Хранить креды безопасно (ConfigService).  
       * Получения клиентов/лидов из AmoCRM.  
       * Создания/обновления клиентов/лидов в AmoCRM.  
       * Получения сделок из AmoCRM.  
       * Создания/обновления сделок в AmoCRM.  
       * Маппинг полей и статусов между MaK CRM и AmoCRM.  
    3. Обработка ошибок, логирование запросов к AmoCRM.  
  * **Ожидаемый результат:** Код для AmoCRMModule, AmoCRMService.  
  * *Файлы: backend/src/amocrm/\*\* (новая папка с модулем)*  
* \[ \] **Задача 2.1.3: Использование BullMQ для асинхронной обработки задач синхронизации.**  
  * **Контекст:** Обеспечение надежной и неблокирующей синхронизации. (Настройка BullMQ будет в Этапе 3, здесь заложить основу).  
  * **Тех. указания:**  
    1. Определить задачи для BullMQ (например, syncContactToAmo, syncDealFromAmo).  
    2. В AmoCRMService вместо прямого вызова API AmoCRM ставить задачи в очередь BullMQ.  
    3. Создать обработчики (processors) для этих задач, которые будут вызывать соответствующие методы AmoCRMService.  
    4. Пока BullMQ не настроен полностью, можно реализовать заглушки или синхронные вызовы с TODO на рефакторинг.  
  * **Ожидаемый результат:** Обновленный AmoCRMService с постановкой задач в очередь (или TODO). Структура для обработчиков.  
  * *Файлы: backend/src/amocrm/amocrm.service.ts, backend/src/jobs/amocrm.processor.ts (новый, или в amocrm модуле)*

#### **Frontend (Next.js)**

* \[ \] **Задача 2.2.1: Интерфейс для настройки и управления интеграцией с AmoCRM администратором.**  
  * **Контекст:** Предоставление UI для управления интеграцией.  
  * **Тех. указания:**  
    1. Создать страницу /admin/integrations/amocrm.  
    2. Форма для ввода учетных данных AmoCRM (API ключ, домен и т.д.). Сохранение на бэкенде (защищенное API).  
    3. Кнопки для запуска/остановки синхронизации (если применимо), просмотра статуса.  
  * **Ожидаемый результат:** Страница настроек интеграции с AmoCRM.  
  * *Файлы: frontend/src/app/admin/integrations/amocrm/page.tsx (новый)*  
* \[ \] **Задача 2.2.2: Отображение статуса синхронизации.**  
  * **Контекст:** Информирование администратора о работе интеграции.  
  * **Тех. указания:** На странице настроек отображать:  
    * Последнее время успешной синхронизации.  
    * Количество синхронизированных записей (если бэкенд предоставляет).  
    * Ошибки синхронизации (если есть).  
    * Бэкенд должен предоставлять API для получения этой информации.  
  * **Ожидаемый результат:** Обновленная страница настроек. API на бэкенде для статуса.  
  * *Файлы: frontend/src/app/admin/integrations/amocrm/page.tsx, backend/src/amocrm/amocrm.controller.ts (новый или доработка существующего админ-контроллера)*

### **Спринт 8: Telegram-бот (2-3 недели)**

**Цель спринта:** Создать Telegram-бота для уведомлений и базовых действий.

#### **Backend (NestJS)**

* \[ \] **Задача 2.3.1: Разработка Telegram-бота (например, с использованием telegraf или node-telegram-bot-api).**  
  * **Контекст:** Создание основы для бота.  
  * **Тех. указания:**  
    1. Установить выбранную библиотеку (например, npm install telegraf).  
    2. Создать TelegramModule, TelegramService.  
    3. Инициализировать бота с токеном из ConfigService.  
    4. Реализовать базовые команды: /start, /help.  
  * **Ожидаемый результат:** Код для TelegramModule, TelegramService.  
  * *Файлы: backend/src/telegram/\*\* (новая папка с модулем)*  
* \[ \] **Задача 2.3.2: Реализация базовых команд: уведомления о новых клиентах/сделках, просмотр информации (ТЗ 2.6).**  
  * **Контекст:** Основной функционал бота.  
  * **Тех. указания:**  
    1. Уведомления: TelegramService должен иметь методы для отправки сообщений пользователям. Интегрировать с ContactsService и DealsService (через события NestJS или прямые вызовы) для отправки уведомлений при создании новых контактов/сделок (пользователям, у которых включены уведомления).  
    2. Просмотр информации: команды типа /mycontacts, /mydeals (с пагинацией через inline-кнопки). Бот должен запрашивать данные у соответствующих сервисов MaK CRM.  
  * **Ожидаемый результат:** Обновленный TelegramService, интеграция с другими сервисами.  
* \[ \] **Задача 2.3.3: Интеграция с системой аутентификации для безопасного доступа к данным через бота.**  
  * **Контекст:** Связывание пользователя Telegram с пользователем MaK CRM.  
  * **Тех. указания:**  
    1. Реализовать механизм связывания аккаунтов: например, пользователь в MaK CRM генерирует одноразовый код, отправляет его боту командой /link \<code\>. Бот проверяет код через API MaK CRM и сохраняет telegramChatId в профиле пользователя MaK CRM.  
    2. При выполнении команд, требующих доступа к данным, бот использует telegramChatId для идентификации пользователя в MaK CRM и проверки его прав.  
  * **Ожидаемый результат:** Логика связывания аккаунтов, API на бэкенде для проверки кода.

#### **Frontend (Next.js)**

* \[ \] **Задача 2.4.1: Интерфейс для администратора для управления настройками Telegram-бота.**  
  * **Контекст:** UI для управления ботом.  
  * **Тех. указания:**  
    1. Страница /admin/integrations/telegram.  
    2. Отображение статуса бота (активен/неактивен).  
    3. Возможно, настройки типов уведомлений для пользователей (пока можно пропустить).  
    4. Интерфейс для пользователей (в их профиле) для генерации кода связывания с Telegram.  
  * **Ожидаемый результат:** Страница настроек Telegram-бота, UI для генерации кода связывания.  
  * *Файлы: frontend/src/app/admin/integrations/telegram/page.tsx (новый), frontend/src/app/profile/page.tsx (доработка)*

### **Спринт 9-10: Единый Кабинет для Внешних Пользователей (Партнёры/Франчайзи) (основа) (3-4 недели)**

**Цель спринтов:** Создать базовую версию Единого Кабинета с разделением доступа и функционала по ролям.

#### **Backend (NestJS)**

* \[ \] **Задача 2.5.1: Доработка RBAC для поддержки ролей "Партнёр" и "Франчайзи".**  
  * **Контекст:** Обеспечение строгого разделения доступа к данным (ТЗ 2.1, 2.4, 2.5).  
  * **Тех. указания:**  
    1. В RolesGuard и сервисах (ContactsService, DealsService) усилить логику фильтрации данных:  
       * Партнёр/Франчайзи видят только те контакты/сделки, где они указаны в поле partnerId.  
       * Убедиться, что они не могут получить доступ к данным других партнёров или внутренним данным компании.  
    2. Проверить все существующие API эндпоинты на корректность применения прав для этих ролей.  
  * **Ожидаемый результат:** Обновленные гарды и сервисы с усиленной логикой RBAC. Набор тестов для проверки изоляции данных.  
* \[ \] **Задача 2.5.2: Разработка API, предоставляющего данные для Единого Кабинета, с логикой, адаптирующей ответ в зависимости от роли пользователя.**  
  * **Контекст:** Подготовка специфичных данных для кабинетов.  
  * **Тех. указания:**  
    1. Создать эндпоинт, например, GET /cabinet/dashboard, который будет возвращать агрегированные данные для дашборда Партнёра/Франчайзи (например, количество их клиентов, сделок, общую сумму сделок). Логика агрегации должна учитывать partnerId текущего пользователя.  
    2. Существующие API (/contacts, /deals) уже должны фильтровать данные по partnerId.  
  * **Ожидаемый результат:** Новый API эндпоинт для дашборда кабинета.  
  * *Файлы: backend/src/cabinet/cabinet.module.ts (новый), backend/src/cabinet/cabinet.controller.ts (новый), backend/src/cabinet/cabinet.service.ts (новый)*  
* \[ \] **Задача 2.5.3: API для управления Партнёрами/Франчайзи своими сотрудниками.**  
  * **Контекст:** Предоставление возможности Партнёрам/Франчайзи управлять своими командами.  
  * **Тех. указания:**  
    1. Эндпоинты для Партнёра/Франчайзи:  
       * GET /cabinet/employees (список своих сотрудников).  
       * POST /cabinet/employees (создание сотрудника, роль PARTNER\_EMPLOYEE, привязка к partnerId текущего пользователя).  
       * PATCH /cabinet/employees/:id (редактирование своего сотрудника).  
       * DELETE /cabinet/employees/:id (удаление своего сотрудника).  
    2. Права, назначаемые сотрудникам, не должны превышать прав самого Партнёра/Франчайзи. (На этом этапе достаточно создания сотрудника с фиксированной ролью PARTNER\_EMPLOYEE).  
  * **Ожидаемый результат:** Новые API эндпоинты в CabinetController или отдельном модуле.

#### **Frontend (Next.js)**

* \[ \] **Задача 2.6.1: Проектирование и разработка базовой структуры Единого Кабинета.**  
  * **Контекст:** Создание отдельного раздела для Партнёров/Франчайзи.  
  * **Тех. указания:**  
    1. Создать новый layout для кабинета, возможно, отличающийся от основного админ-интерфейса (frontend/src/app/(cabinet)/layout.tsx).  
    2. Навигация в кабинете (боковая панель или хедер) с пунктами, релевантными для Партнёров/Франчайзи.  
  * **Ожидаемый результат:** Структура папок и layout для кабинета.  
  * *Файлы: frontend/src/app/(cabinet)/layout.tsx (новый), frontend/src/app/(cabinet)/dashboard/page.tsx (новый)*  
* \[ \] **Задача 2.6.2: Реализация механизма автоматического определения отображаемого функционала на основе роли пользователя.**  
  * **Контекст:** Динамическое отображение UI в зависимости от роли.  
  * **Тех. указания:**  
    1. В AuthProvider или аналогичном месте хранить роль текущего пользователя.  
    2. Использовать эту роль для условного рендеринга навигации и разделов в Едином Кабинете.  
    3. Например, Франчайзи может видеть раздел "Аукцион лидов" (пока заглушка), а Партнёр \- "Реферальная программа" (заглушка).  
  * **Ожидаемый результат:** Обновленный AuthProvider, условный рендеринг в компонентах кабинета.  
* \[ \] **Задача 2.6.3: Начальное отображение списков клиентов/лидов и сделок, отфильтрованных для данного пользователя и его роли.**  
  * **Контекст:** Предоставление доступа к своим данным.  
  * **Тех. указания:**  
    1. Создать страницы в Едином Кабинете для просмотра своих контактов и сделок (например, /cabinet/contacts, /cabinet/deals).  
    2. Переиспользовать компоненты ContactsTable и DealsList/DealsKanbanBoard, убедившись, что они корректно работают с API, которое уже фильтрует данные по partnerId.  
  * **Ожидаемый результат:** Страницы со списками контактов и сделок в кабинете.  
  * *Файлы: frontend/src/app/(cabinet)/contacts/page.tsx (новый), frontend/src/app/(cabinet)/deals/page.tsx (новый)*  
* \[ \] **Задача 2.6.4: Базовая аналитика, доступная в кабинете, с учетом роли пользователя.**  
  * **Контекст:** Отображение ключевых показателей для Партнёров/Франчайзи.  
  * **Тех. указания:**  
    1. На странице /cabinet/dashboard отобразить базовые метрики, полученные от API GET /cabinet/dashboard.  
    2. Использовать простые компоненты Mantine для отображения (например, StatsGrid).  
  * **Ожидаемый результат:** Дашборд в кабинете с базовой аналитикой.  
  * *Файлы: frontend/src/app/(cabinet)/dashboard/page.tsx*  
* \[ \] **Задача 2.6.5: Реализация интерфейса для Партнёров/Франчайзи по созданию и управлению своими сотрудниками.**  
  * **Контекст:** UI для управления командой.  
  * **Тех. указания:**  
    1. Создать страницу /cabinet/employees.  
    2. Таблица со списком сотрудников (TanStack Table).  
    3. Формы для создания/редактирования сотрудников (React Hook Form \+ Mantine).  
    4. Интеграция с API GET /cabinet/employees, POST /cabinet/employees и т.д.  
  * **Ожидаемый результат:** Интерфейс для управления сотрудниками в кабинете.  
  * *Файлы: frontend/src/app/(cabinet)/employees/page.tsx (новый), frontend/src/components/Cabinet/EmployeeForm.tsx (новый)*

## **Этап 3: Real-time, Фоновые задачи и Расширенный UI/UX (6-8 недель)**

**Цель этапа:** Внедрить WebSocket для обновлений в реальном времени, настроить систему фоновых задач, улучшить пользовательский интерфейс.

### **Спринт 11: Real-time отслеживание статусов заявок (2-3 недели)**

**Цель спринта:** Реализовать WebSocket для динамического обновления статусов заявок для Франчайзи.

#### **Backend (NestJS)**

* \[ \] **Задача 3.1.1: Разработка WebSocket Gateway (Socket.IO) для обновлений статусов.**  
  * **Контекст:** Создание сервера для real-time коммуникаций (Дополнение к ТЗ, Задача 1.1).  
  * **Тех. указания:**  
    1. Установить зависимости: npm install @nestjs/websockets @nestjs/platform-socket.io socket.io.  
    2. Создать RealtimeModule и RealtimeGateway (src/realtime/realtime.gateway.ts).  
    3. Реализовать обработчики событий connection и disconnect.  
    4. Метод в RealtimeGateway для отправки сообщений клиентам в определенные "комнаты" (например, по franchiseeId).  
    5. Событие для отправки: applicationStatusUpdated (payload: { applicationId, newStatus, details }).  
  * **Ожидаемый результат:** Код для RealtimeGateway.  
  * *Файлы: backend/src/realtime/\*\* (новая папка с модулем)*  
* \[ \] **Задача 3.1.2: Настройка WebSocket адаптера для Redis.**  
  * **Контекст:** Масштабирование WebSocket сервера (Дополнение к ТЗ, Задача 1.2).  
  * **Тех. указания:**  
    1. Установить адаптер: npm install @socket.io/redis-adapter.  
    2. В main.ts или RealtimeModule настроить WebSocket-сервер на использование Redis адаптера, подключившись к существующему Redis инстансу.  
  * **Ожидаемый результат:** Обновленная конфигурация WebSocket.  
  * *Файлы: backend/src/main.ts или backend/src/realtime/realtime.module.ts*  
* \[ \] **Задача 3.1.3: Интеграция WebSocket Gateway с сервисами (например, DealsService).**  
  * **Контекст:** Отправка real-time уведомлений при изменении статусов.  
  * **Тех. указания:**  
    1. В DealsService (или где происходит изменение статусов заявок/сделок, релевантных для Франчайзи), после успешного обновления статуса, вызывать метод RealtimeGateway для отправки события applicationStatusUpdated в комнату соответствующего Франчайзи.  
  * **Ожидаемый результат:** Обновленный сервис (например, DealsService) с вызовами RealtimeGateway.

#### **Frontend (Next.js)**

* \[ \] **Задача 3.2.1: Реализация WebSocket клиента в Едином Кабинете для пользователей с ролью "Франчайзи".**  
  * **Контекст:** Получение и отображение обновлений в реальном времени (Дополнение к ТЗ, Задача 1.3).  
  * **Тех. указания:**  
    1. Установить socket.io-client: npm install socket.io-client.  
    2. В компоненте Единого Кабинета, который отображает заявки/сделки Франчайзи, инициализировать WebSocket клиент.  
    3. Реализовать подключение к WebSocket серверу (с передачей JWT токена для аутентификации на WebSocket, если это настроено на бэкенде).  
    4. Подписаться на событие applicationStatusUpdated.  
    5. При получении события обновлять UI (например, статус конкретной сделки в таблице/канбан-доске) без перезагрузки страницы.  
    6. Обработка ошибок подключения и переподключения.  
  * **Ожидаемый результат:** Код WebSocket клиента на фронтенде, обновление UI при получении событий.  
  * *Файлы: frontend/src/app/(cabinet)/deals/page.tsx (или соответствующий компонент)*

### **Спринт 12: Система фоновых задач и очередей (2-3 недели)**

**Цель спринта:** Настроить и интегрировать BullMQ для управления очередями и фоновыми задачами.

#### **Backend (NestJS/Redis)**

* \[ \] **Задача 3.3.1: Интеграция BullMQ для управления очередями.**  
  * **Контекст:** Настройка системы очередей (Дополнение к ТЗ, Задача 2.1).  
  * **Тех. указания:**  
    1. Установить BullMQ: npm install bullmq @nestjs/bullmq.  
    2. Настроить BullModule в AppModule или отдельном JobsModule, указав подключение к Redis.  
    3. Создать очереди (например, notificationsQueue, amoCRMSyncQueue, pipelineActionsQueue).  
  * **Ожидаемый результат:** Настроенный BullModule с очередями.  
  * *Файлы: backend/src/app.module.ts (или backend/src/jobs/jobs.module.ts)*  
* \[ \] **Задача 3.3.2: Разработка сервисов-продюсеров и обработчиков задач.**  
  * **Контекст:** Реализация логики для постановки и обработки задач (Дополнение к ТЗ, Задачи 2.2, 2.3).  
  * **Тех. указания:**  
    1. **Продюсеры:** В сервисах, где требуется асинхронная обработка (например, AmoCRMService для синхронизации, NotificationsService для отправки уведомлений, DealsService для автоматизации воронки), добавлять задачи в соответствующие очереди BullMQ.  
    2. **Обработчики (Processors):** Для каждой очереди создать класс-обработчик (@Processor('queueName')) с методами, аннотированными @Process('jobName'), которые будут выполнять реальную работу.  
       * Пример: AmoCRMSyncProcessor для amoCRMSyncQueue.  
       * Пример: NotificationProcessor для notificationsQueue.  
    3. Рефакторить код, где ранее были заглушки для асинхронности (например, в AmoCRM интеграции).  
  * **Ожидаемый результат:** Код для продюсеров и обработчиков задач.  
  * *Файлы: backend/src/amocrm/amocrm.service.ts (обновление), backend/src/jobs/processors/amocrm.processor.ts (новый), backend/src/notifications/notifications.service.ts (новый, если еще нет), backend/src/jobs/processors/notification.processor.ts (новый)*  
* \[ \] **Задача 3.3.3: Настройка UI для мониторинга очередей (например, Arena или Bull Board).**  
  * **Контекст:** Инструмент для отслеживания состояния очередей (Дополнение к ТЗ, Задача 2.4).  
  * **Тех. указания:**  
    1. Выбрать UI (например, @bull-board/nestjs и @bull-board/express). Установить.  
    2. Настроить его как отдельный эндпоинт или модуль в NestJS, защищенный аутентификацией (только для администраторов).  
  * **Ожидаемый результат:** Рабочий UI для мониторинга очередей.  
  * *Файлы: backend/src/main.ts (или отдельный модуль для Bull Board)*

### **Спринт 13: Расширенный UI/UX (Drag\&Drop, Inline-редактирование) (2-3 недели)**

**Цель спринта:** Улучшить интерактивность и удобство использования интерфейса.

#### **Frontend (Next.js)**

* \[ \] **Задача 3.4.1: Реализация Drag\&Drop для канбан-доски сделок (dnd-kit).**  
  * **Контекст:** Улучшение канбан-доски (ТЗ 2.3). (Базовая реализация была в Спринте 5, здесь доработка).  
  * **Тех. указания:**  
    1. Убедиться, что Drag\&Drop работает плавно и корректно обновляет данные на бэкенде.  
    2. Добавить визуальную обратную связь при перетаскивании (например, изменение стиля перетаскиваемого элемента, подсветка зоны для бросания).  
    3. Обеспечить доступность (a11y) для управления с клавиатуры, если это возможно с dnd-kit.  
  * **Ожидаемый результат:** Улучшенная канбан-доска.  
  * *Файлы: frontend/src/components/Deals/DealsKanbanBoard.tsx*  
* \[ \] **Задача 3.4.2: Реализация Inline-редактирования в таблицах (TanStack Table).**  
  * **Контекст:** Возможность быстрого редактирования данных прямо в таблице (ТЗ 2.3).  
  * **Тех. указания:**  
    1. Для ключевых полей в ContactsTable и DealsTable (например, статус, сумма сделки, ответственный) реализовать inline-редактирование.  
    2. При клике на поле оно должно превращаться в инпут/селект.  
    3. После изменения и потери фокуса (или нажатия Enter) отправлять запрос на бэкенд для сохранения изменений.  
    4. Использовать возможности TanStack Table для управления состоянием редактирования ячеек.  
  * **Ожидаемый результат:** Таблицы с возможностью inline-редактирования.  
  * *Файлы: frontend/src/components/Contacts/ContactsTable.tsx, frontend/src/components/Deals/DealsList.tsx (если используется таблица)*  
* \[ \] **Задача 3.4.3: Доработка трехколоночного интерфейса для сделок.**  
  * **Контекст:** Улучшение страницы просмотра/редактирования сделки (ТЗ 2.3).  
  * **Тех. указания:**  
    1. На странице отдельной сделки (/deals/\[id\]) реализовать трехколоночный layout:  
       * Левая колонка: информация о клиенте/сделке (детали сделки, информация о связанном контакте).  
       * Центральная колонка: история взаимодействия (комментарии, история изменений статусов, задачи по сделке \- задачи пока заглушка).  
       * Правая колонка: панель автоматизаций (пока заглушка, будет реализована позже).  
    2. Использовать компоненты Mantine для разметки.  
  * **Ожидаемый результат:** Обновленный интерфейс страницы сделки.  
  * *Файлы: frontend/src/app/deals/\[id\]/page.tsx (или соответствующий компонент)*  
* \[ \] **Задача 3.4.4: Улучшение адаптивности и общей отзывчивости интерфейса.**  
  * **Контекст:** Обеспечение корректного отображения на различных устройствах.  
  * **Тех. указания:**  
    1. Протестировать все существующие страницы на планшетах и мобильных устройствах.  
    2. Исправить проблемы с версткой, используя адаптивные возможности Mantine и Tailwind CSS.  
    3. Особое внимание уделить таблицам, формам, канбан-доске.  
  * **Ожидаемый результат:** Улучшенная адаптивность интерфейса. (Затрагивает многие файлы CSS и компоненты).

## **Этап 4: Аналитика, Сложные UI и Безопасность (8-10 недель)**

**Цель этапа:** Внедрить продвинутую аналитику, разработать сложные UI компоненты (конструктор отчетов, редактор автоматизаций) и усилить безопасность системы.

### **Спринт 14-15: Аналитика, Отчёты и Дашборды (3-4 недели)**

**Цель спринтов:** Реализовать функционал встроенных отчетов, конструктора отчетов и настраиваемых дашбордов.

#### **Backend (NestJS/PostgreSQL/Elasticsearch)**

* \[ \] **Задача 4.1.1: Разработка API для встроенных отчетов (воронка продаж, эффективность и т.д. \- ТЗ 2.9).**  
  * **Контекст:** Предоставление данных для стандартных отчетов.  
  * **Тех. указания:**  
    1. Создать AnalyticsModule, AnalyticsController, AnalyticsService.  
    2. Реализовать API эндпоинты для получения данных для отчетов:  
       * GET /analytics/sales-funnel (данные для воронки продаж: этапы, количество сделок, конверсия).  
       * GET /analytics/employee-effectiveness (данные по эффективности сотрудников/партнеров: количество сделок, сумма, конверсия).  
       * GET /analytics/lead-sources (эффективность источников клиентов).  
       * ... другие отчеты согласно ТЗ 2.9.  
    3. API должны учитывать RBAC: Администратор видит все данные, Менеджер \- свои/разрешенные, Партнер/Франчайзи \- только свои данные (фильтрация по partnerId или assignedUserId).  
    4. Для агрегации данных использовать PostgreSQL (сложные SQL запросы) и/или Elasticsearch (агрегации).  
    5. Оптимизировать запросы для производительности.  
  * **Ожидаемый результат:** Код для AnalyticsModule, API эндпоинты для встроенных отчетов. Юнит-тесты для AnalyticsService.  
  * *Файлы: backend/src/analytics/\*\* (новая папка с модулем)*  
* \[ \] **Задача 4.1.2: Проектирование и реализация API для "Конструктора отчётов".**  
  * **Контекст:** Обеспечение бэкенд-поддержки для кастомных отчетов (Дополнение к ТЗ для ИИ, Задача 3.B.3).  
  * **Тех. указания:**  
    1. Определить структуру запроса для конструктора отчетов (например, какие сущности, поля, фильтры, группировки, агрегации выбраны пользователем).  
    2. Разработать API эндпоинт POST /analytics/custom-report который принимает эту структуру запроса.  
    3. AnalyticsService должен динамически генерировать SQL-запрос (или Elasticsearch query) на основе полученной структуры.  
       * **Безопасность:** Крайне важно предотвратить SQL-инъекции. Использовать ORM-возможности Prisma для построения запросов или тщательно санировать все входные данные, если генерируется сырой SQL.  
    4. API должен возвращать данные отчета.  
    5. Реализовать API для сохранения/загрузки шаблонов кастомных отчетов (POST /analytics/report-templates, GET /analytics/report-templates).  
  * **Ожидаемый результат:** API для конструктора отчетов и управления шаблонами.  
  * *Файлы: backend/src/analytics/analytics.controller.ts, backend/src/analytics/analytics.service.ts*

#### **Frontend (Next.js)**

* \[ \] **Задача 4.2.1: Разработка интерфейса для встроенных отчетов с визуализацией (Recharts/Nivo).**  
  * **Контекст:** Отображение стандартных отчетов для пользователей.  
  * **Тех. указания:**  
    1. Создать страницы для каждого встроенного отчета (например, /analytics/sales-funnel, /analytics/employee-effectiveness) или единую страницу с выбором отчета.  
    2. Использовать библиотеки Recharts (npm install recharts) или Nivo (npm install @nivo/core @nivo/bar и т.д.) для визуализации данных (графики, диаграммы).  
    3. Интегрировать с API бэкенда для получения данных.  
    4. Адаптировать отображение для Единого Кабинета (Партнёры/Франчайзи видят только свои данные).  
  * **Ожидаемый результат:** Компоненты и страницы для встроенных отчетов с визуализацией.  
  * *Файлы: frontend/src/app/analytics/\*\* (новая папка), frontend/src/components/Analytics/\*\* (новые компоненты для графиков)*  
* \[ \] **Задача 4.2.2: Реализация интерфейса "Конструктора отчётов".**  
  * **Контекст:** UI для создания кастомных отчетов (Дополнение к ТЗ для ИИ, Задача 3.B.1).  
  * **Тех. указания:**  
    1. Создать страницу /analytics/custom-report-builder.  
    2. Интерфейс должен позволять пользователю:  
       * Выбирать сущность для отчета (Клиенты, Сделки).  
       * Выбирать поля для отображения.  
       * Задавать фильтры по полям.  
       * Выбирать поля для группировки.  
       * Выбирать агрегирующие функции (COUNT, SUM, AVG).  
       * Выбирать тип визуализации (таблица, график).  
    3. Формировать структуру запроса и отправлять на API POST /analytics/custom-report.  
    4. Отображать полученные данные (в таблице или с помощью Recharts/Nivo).  
    5. Реализовать сохранение/загрузку шаблонов отчетов.  
  * **Ожидаемый результат:** Интерфейс конструктора отчетов.  
  * *Файлы: frontend/src/app/analytics/custom-report-builder/page.tsx, frontend/src/components/Analytics/ReportBuilder/\*\* (новые компоненты)*  
* \[ \] **Задача 4.2.3: Разработка настраиваемых дашбордов (базовая версия).**  
  * **Контекст:** Предоставление пользователям возможности создавать персонализированные дашборды.  
  * **Тех. указания:**  
    1. Пользователь должен иметь возможность добавлять на дашборд виджеты (например, сохраненные отчеты из конструктора или встроенные отчеты).  
    2. Реализовать базовую сетку для размещения виджетов (например, с использованием Mantine Grid или react-grid-layout npm install react-grid-layout).  
    3. Сохранение конфигурации дашборда для пользователя (на бэкенде).  
    4. Начать с одного дашборда на пользователя.  
  * **Ожидаемый результат:** Базовый функционал настраиваемых дашбордов.  
  * *Файлы: frontend/src/app/dashboard/page.tsx (доработка или новый), backend API для сохранения/загрузки конфигурации дашборда*

### **Спринт 16: Визуальный редактор автоматизаций (начальная версия) (2-3 недели)**

**Цель спринта:** Создать начальную версию визуального редактора для автоматизации воронки продаж.

#### **Frontend (Next.js)**

* \[ \] **Задача 4.3.1: Разработка интерфейса визуального редактора автоматизаций.**  
  * **Контекст:** UI для создания правил автоматизации (Дополнение к ТЗ для ИИ, Задача 3.A.1).  
  * **Тех. указания:**  
    1. Создать страницу, например, /pipelines/:id/automations.  
    2. Использовать библиотеку для создания графоподобных интерфейсов (например, React Flow npm install reactflow или dnd-kit для более простого варианта).  
    3. Пользователь должен иметь возможность:  
       * Добавлять триггеры (например, "Сделка перешла на этап X", "Создан новый клиент").  
       * Добавлять условия (например, "Сумма сделки \> Y", "Источник клиента \= Z").  
       * Добавлять действия (например, "Отправить уведомление", "Сменить ответственного", "Создать задачу" \- пока заглушки для действий).  
       * Связывать эти блоки для создания цепочки автоматизации.  
    4. Фокус на базовых триггерах, условиях и действиях для MVP.  
  * **Ожидаемый результат:** Интерфейс визуального редактора автоматизаций.  
  * *Файлы: frontend/src/app/pipelines/\[id\]/automations/page.tsx, frontend/src/components/AutomationsEditor/\*\* (новые компоненты)*

#### **Backend (NestJS)**

* \[ \] **Задача 4.4.1: Определение JSON-структуры для правил автоматизации.**  
  * **Контекст:** Формат хранения и передачи правил автоматизации (Дополнение к ТЗ для ИИ, Задача 3.A.2).  
  * **Тех. указания:**  
    1. Разработать JSON-схему, которая будет представлять правила, созданные в визуальном редакторе (триггеры, условия, действия, их связи).  
    2. Эта структура будет сохраняться в БД (например, в сущности Pipeline или отдельной сущности AutomationRule).  
    3. Добавить соответствующее поле в Prisma schema (например, automationsJson: Json? в PipelineStage или Pipeline).  
  * **Ожидаемый результат:** JSON-схема для правил автоматизации, обновленная Prisma schema и миграция.  
  * *Файлы: backend/prisma/schema.prisma, документация по JSON-схеме*  
* \[ \] **Задача 4.4.2: Начальная реализация механизма исполнения простых правил автоматизации.**  
  * **Контекст:** Запуск автоматизаций при наступлении событий (Дополнение к ТЗ для ИИ, Задача 3.A.3).  
  * **Тех. указания:**  
    1. Создать AutomationsService.  
    2. Реализовать логику, которая будет срабатывать при определенных событиях в системе (например, обновление сделки).  
    3. Эта логика должна загружать сохраненные JSON-правила автоматизации для соответствующей воронки/этапа.  
    4. Парсить JSON и исполнять определенные действия (пока можно реализовать только логирование или простые действия, например, обновление поля сделки).  
    5. Использовать систему событий NestJS (@nestjs/event-emitter) для запуска проверок автоматизаций.  
  * **Ожидаемый результат:** Код для AutomationsService, интеграция с системными событиями.  
  * *Файлы: backend/src/automations/automations.module.ts (новый), backend/src/automations/automations.service.ts (новый)*

### **Спринт 17: Безопасность и Соответствие ФЗ-152 (2-3 недели)**

**Цель спринта:** Усилить безопасность системы, внедрить 2FA и провести базовые мероприятия по ФЗ-152.

#### **Backend & Frontend**

* \[ \] **Задача 4.5.1: Внедрение двухфакторной аутентификации (2FA).**  
  * **Контекст:** Повышение безопасности аутентификации (ТЗ 2.10).  
  * **Тех. указания:**  
    1. **Backend:**  
       * Реализовать поддержку TOTP (Time-based One-Time Password, например, с speakeasy и qrcode).  
       * API для включения 2FA пользователем (генерация секрета, QR-кода).  
       * API для проверки TOTP-кода при логине.  
       * Сохранять секрет 2FA для пользователя в БД.  
       * Реализовать резервные коды.  
    2. **Frontend:**  
       * UI для включения 2FA (отображение QR-кода, ввод кода подтверждения).  
       * Поле для ввода TOTP-кода на странице логина, если 2FA включена.  
       * UI для управления резервными кодами.  
  * **Ожидаемый результат:** Реализованный функционал 2FA.  
  * *Файлы: backend/src/auth/\*\* (доработки), frontend/src/app/profile/security/page.tsx (новый), frontend/src/app/login/page.tsx (доработка)*  
* \[ \] **Задача 4.5.2: Интеграция с внешними сервисами авторизации РФ (Госуслуги и др. \- базовая подготовка).**  
  * **Контекст:** Предоставление альтернативных способов входа (ТЗ 2.10).  
  * **Тех. указания:**  
    1. Исследовать API одного из сервисов (например, Госуслуги ЕСИА, если доступна тестовая среда).  
    2. **Backend:** Заложить основу для OAuth 2.0 / OpenID Connect интеграции (например, с использованием Passport.js стратегий, если есть). На этом этапе можно создать заглушки для контроллеров и сервисов.  
    3. **Frontend:** Добавить кнопки "Войти через X" на страницу логина (пока неактивные или ведущие на заглушку).  
  * **Ожидаемый результат:** Исследование API, базовая структура для OAuth-интеграции на бэкенде, кнопки на UI.  
  * *Файлы: backend/src/auth/strategies/gosuslugi.strategy.ts (новый, заглушка), frontend/src/app/login/page.tsx (доработка)*  
* \[ \] **Задача 4.5.3: Реализация аудита действий пользователей.**  
  * **Контекст:** Логирование важных действий для безопасности и анализа (ТЗ 2.10).  
  * **Тех. указания:**  
    1. **Backend:**  
       * Создать AuditLogModule, AuditLogService.  
       * Определить события для логирования (например, вход/выход, создание/изменение/удаление ключевых сущностей: Клиент, Сделка, Пользователь).  
       * Использовать систему событий NestJS или interceptors/decorators для автоматического логирования.  
       * Сохранять логи в PostgreSQL (отдельная таблица AuditLog: id, userId, action, entity, entityId, timestamp, details: Json?) и/или Elasticsearch для удобного поиска.  
    2. **Frontend:** (Если требуется отображение) UI для администратора для просмотра логов аудита (с фильтрацией, пагинацией).  
  * **Ожидаемый результат:** Система логирования аудита, API и UI (опционально) для просмотра логов.  
  * *Файлы: backend/src/audit-log/\*\* (новый модуль), frontend/src/app/admin/audit-logs/page.tsx (новый, если реализуется UI)*  
* \[ \] **Задача 4.5.4: Проверка и доработка системы на соответствие требованиям ФЗ-152 (базовые аспекты).**  
  * **Контекст:** Обеспечение защиты персональных данных (ТЗ 2.10).  
  * **Тех. указания:**  
    1. Проверить шифрование чувствительных данных (пароли уже хешируются, рассмотреть шифрование определенных полей ПДн в БД, если необходимо).  
    2. Обеспечить логику для получения согласия на обработку ПДн (например, чекбокс при регистрации, ссылка на политику конфиденциальности).  
    3. **Frontend:** Добавить чекбокс "Согласен на обработку ПДн" на форму регистрации.  
    4. **Backend:** Сохранять факт согласия.  
    5. Подготовить шаблон Политики конфиденциальности и Пользовательского соглашения (ИИ может помочь с генерацией черновиков).  
  * **Ожидаемый результат:** Чекбокс согласия, сохранение факта согласия, черновики документов.  
  * *Файлы: frontend/src/app/register/page.tsx (доработка), backend/src/auth/auth.service.ts (доработка)*  
* \[ \] **Задача 4.5.5: Проведение базового аудита безопасности, настройка security headers (helmet).**  
  * **Контекст:** Общее усиление безопасности веб\-приложения.  
  * **Тех. указания:**  
    1. **Backend (NestJS):**  
       * Установить и настроить helmet: npm install helmet. Использовать app.use(helmet()); в main.ts.  
       * Проверить основные OWASP Top 10 уязвимости (XSS, CSRF, SQL Injection \- Prisma помогает с последним). Для CSRF, если используются cookie-based сессии, NestJS предоставляет защиту. Для JWT, если токены передаются в Authorization header, CSRF менее релевантен для API.  
    2. **Frontend (Next.js):** Next.js по умолчанию применяет некоторые security headers. Проверить конфигурацию.  
    3. Провести базовое сканирование зависимостей на уязвимости (npm audit).  
  * **Ожидаемый результат:** Настроен helmet, проведен базовый аудит.  
  * *Файлы: backend/src/main.ts (доработка)*

## **Этап 5: Формализация Каталога Компонентов, Разработка Интерфейса Управления и Подготовка к Расширению (6-8 недель)**

**Цель этапа:** Создать формализованную систему управления дополнительными и опциональными компонентами/модулями, а также подготовить документацию для разработчиков этих компонентов. Основные функциональные блоки, разработанные ранее, уже спроектированы с учетом модульности.

### **Спринт 18-19: Архитектура и Реализация Каталога Компонентов (4-5 недель)**

**Цель спринтов:** Спроектировать и реализовать ядро Каталога Компонентов, позволяющее Администратору управлять (активировать/деактивировать, настраивать) дополнительными модулями.

#### **Архитектура, Backend (NestJS), Frontend (Next.js)**

* \[ \] **Задача 5.1.1: Проектирование API и контрактов для компонентов Каталога.**  
  * **Контекст:** Определение способов взаимодействия между ядром CRM и подключаемыми компонентами (Дополнение к ТЗ для ИИ, Задача 4.1).  
  * **Тех. указания:**  
    1. Определить интерфейсы (TypeScript) для регистрации компонента в системе (метаданные: имя, версия, описание, зависимости, конфигурационные параметры).  
    2. Определить, как компоненты будут предоставлять свою функциональность ядру (например, через предопределенные точки расширения, события, или API, которое они реализуют).  
    3. Продумать, как компоненты могут получать доступ к данным ядра (безопасно, через API ядра).  
    4. Разработать OpenAPI спецификацию для API управления компонентами (активация, деактивация, конфигурация).  
  * **Ожидаемый результат:** Документ с описанием архитектуры Каталога, TypeScript интерфейсы, OpenAPI спецификация для API управления.  
* \[ \] **Задача 5.1.2: Реализация бэкенд-поддержки для Каталога Компонентов.**  
  * **Контекст:** Создание на бэкенде механизма управления жизненным циклом и конфигурацией компонентов (Дополнение к ТЗ для ИИ, Задача 4.2).  
  * **Тех. указания:**  
    1. Создать ComponentsModule, ComponentsController, ComponentsService на бэкенде.  
    2. Реализовать хранение информации о доступных и активных компонентах в БД (новая таблица RegisteredComponent в Prisma: id, nameKey (уникальный ключ компонента), version, isActive, configuration: Json?).  
    3. API для Администратора:  
       * GET /components (список всех зарегистрированных компонентов, их статус, конфигурация).  
       * POST /components/:nameKey/activate (активация компонента).  
       * POST /components/:nameKey/deactivate (деактивация компонента).  
       * PATCH /components/:nameKey/configure (обновление конфигурации компонента).  
    4. Механизм для регистрации новых компонентов (может быть ручным через БД на начальном этапе или через API).  
  * **Ожидаемый результат:** Код для ComponentsModule на бэкенде, обновленная Prisma schema и миграция.  
  * *Файлы: backend/src/components/\*\* (новая папка с модулем), backend/prisma/schema.prisma*  
* \[ \] **Задача 5.1.3: Реализация фронтенд-поддержки для Каталога Компонентов.**  
  * **Контекст:** UI для Администратора для управления компонентами и динамическая загрузка UI частей компонентов (Дополнение к ТЗ для ИИ, Задача 4.3).  
  * **Тех. указания:**  
    1. Создать страницу /admin/components-catalog для Администратора.  
    2. Отображение списка компонентов с возможностью активации/деактивации и базовой настройки (вызов API бэкенда).  
    3. Реализовать механизм динамической загрузки UI-частей активных компонентов. Использовать Next.js next/dynamic для импорта UI-компонентов, предоставляемых модулями.  
    4. Продумать, как компоненты будут встраивать свой UI в предопределенные места в основном интерфейсе (например, виджеты на дашборд, новые пункты меню).  
  * **Ожидаемый результат:** Страница управления компонентами, пример механизма динамической загрузки.  
  * *Файлы: frontend/src/app/admin/components-catalog/page.tsx, примеры компонентов для динамической загрузки*  
* \[ \] **Задача 5.1.4: Разработка 1-2 пилотных компонентов для каталога.**  
  * **Контекст:** Проверка работоспособности архитектуры каталога на практических примерах.  
  * **Тех. указания:**  
    1. **Пример 1: Простой виджет для дашборда.**  
       * Backend: Может не требоваться, если виджет отображает статические данные или данные, уже доступные через API ядра.  
       * Frontend: React-компонент, который регистрируется в каталоге и отображается на главном дашборде, если активен.  
    2. **Пример 2: Базовый отчет (не из конструктора).**  
       * Backend: Небольшой NestJS модуль, предоставляющий API для данных отчета. Регистрируется в каталоге.  
       * Frontend: Страница или компонент, отображающий этот отчет, использующий API пилотного бэкенд-модуля. Динамически добавляется в навигацию.  
    3. Оба компонента должны управляться (активация/деактивация) через интерфейс Каталога Компонентов.  
  * **Ожидаемый результат:** Код для 1-2 пилотных компонентов (фронтенд и, возможно, бэкенд части).  
  * *Файлы: backend/src/components/pilots/dashboard-widget/\*\* (пример), frontend/src/components/pilots/DashboardWidget.tsx (пример)*

### **Спринт 20: Документация для разработчиков компонентов и API (2-3 недели)**

**Цель спринта:** Создать исчерпывающую документацию, которая позволит сторонним разработчикам (или внутренним командам в будущем) создавать и интегрировать новые компоненты в систему, а также финализировать основную API документацию.

#### **Документация**

* \[ \] **Задача 5.2.1: Создание документации по API Каталога компонентов.**  
  * **Контекст:** Описание того, как разрабатывать компоненты, совместимые с каталогом (Дополнение к ТЗ для ИИ, Задача 4.4).  
  * **Тех. указания:**  
    1. Описать процесс регистрации компонента.  
    2. Детализировать контракты и интерфейсы, которые компонент должен реализовывать.  
    3. Описать, как компонент может взаимодействовать с ядром CRM (доступ к API ядра, события).  
    4. Привести примеры кода для бэкенд и фронтенд частей компонента.  
    5. Описать жизненный цикл компонента (установка, активация, конфигурация, деактивация, удаление).  
  * **Ожидаемый результат:** Страница(ы) в документации (например, в Confluence, MkDocs, или просто Markdown файлы в репозитории).  
* \[ \] **Задача 5.2.2: Разработка гайдлайнов и примеров для создания новых компонентов.**  
  * **Контекст:** Предоставление лучших практик и шаблонов для разработчиков компонентов.  
  * **Тех. указания:**  
    1. Рекомендации по структуре проекта компонента.  
    2. Правила именования, стиль кода.  
    3. Рекомендации по безопасности для компонентов.  
    4. Примеры реализации различных типов компонентов (виджет, страница, бэкенд-сервис).  
    5. Создать шаблон/boilerplate репозитория для нового компонента.  
  * **Ожидаемый результат:** Документ с гайдлайнами, примеры кода, ссылка на шаблон репозитория.  
* \[ \] **Задача 5.2.3: Финализация и публикация основной документации API системы (Swagger/OpenAPI).**  
  * **Контекст:** Обеспечение актуальной и полной документации для всех API ядра системы (ТЗ 2.6, 4.6).  
  * **Тех. указания:**  
    1. Проверить все существующие эндпоинты на наличие актуальной OpenAPI документации (сгенерированной NestJS).  
    2. Дополнить описания, примеры запросов/ответов, DTO.  
    3. Настроить удобный доступ к Swagger UI или ReDoc для опубликованной документации.  
  * **Ожидаемый результат:** Опубликованная и полная документация API ядра.  
* \[ \] **Задача 5.2.4: Подготовка базовых руководств пользователя.**  
  * **Контекст:** Создание документации для конечных пользователей системы (ТЗ 4.6).  
  * **Тех. указания:**  
    1. Описать основной функционал для каждой роли (Администратор, Менеджер, Партнер, Франчайзи).  
    2. Инструкции по выполнению ключевых задач (например, создание клиента, управление сделкой, просмотр отчетов).  
    3. Использовать скриншоты (разработчик предоставит).  
    4. Формат: Markdown файлы, Wiki, или другая система документации. Начать с ключевых функций MVP.  
  * **Ожидаемый результат:** Черновики базовых руководств пользователя для основных ролей и функций.

## **Этап 6: Опциональный GraphQL, Оптимизация и Финальная Документация (4-6 недель)**

**Цель этапа:** Рассмотреть целесообразность и, при необходимости, реализовать GraphQL API для сложных запросов. Провести оптимизацию производительности системы. Завершить всю пользовательскую и техническую документацию.

### **Спринт 21: Рассмотрение и Реализация GraphQL (если принято решение) (2-3 недели)**

**Цель спринта:** Проанализировать необходимость GraphQL и, в случае положительного решения, разработать и интегрировать GraphQL API.

#### **Анализ, Backend (NestJS), Frontend (Next.js)**

* \[ \] **Задача 6.1.1: Проведение анализа целесообразности GraphQL для сложных запросов.**  
  * **Контекст:** Оценка преимуществ и недостатков GraphQL для текущего проекта (Дополнение к ТЗ для ИИ, Задача 5.1).  
  * **Тех. указания:**  
    1. Идентифицировать сценарии, где REST API может быть неэффективным (например, множество связанных запросов от клиента, необходимость получения только определенных полей из сложных структур).  
    2. Оценить сложность внедрения и поддержки GraphQL (дополнительные зависимости, написание resolvers, управление схемой).  
    3. Сравнить с возможностями оптимизации REST API (например, использование query parameters для выбора полей, расширение существующих эндпоинтов).  
    4. Подготовить краткий отчет для разработчика с рекомендацией (внедрять GraphQL или нет) и обоснованием.  
  * **Ожидаемый результат:** Документ с анализом и рекомендацией.  
* \[ \] **Задача 6.1.2 (Если принято решение внедрять GraphQL): Разработка GraphQL API на NestJS.**  
  * **Контекст:** Реализация GraphQL сервера (Дополнение к ТЗ для ИИ, Задача 5.2).  
  * **Тех. указания:**  
    1. Установить зависимости: npm install @nestjs/graphql @nestjs/apollo @apollo/server graphql graphql-tools.  
    2. Настроить GraphQLModule в NestJS (code-first подход).  
    3. Создать GraphQL types, queries, mutations и resolvers для нескольких ключевых сущностей (например, User, Contact, Deal), которые были определены как подходящие для GraphQL в Задаче 6.1.1.  
    4. Обеспечить интеграцию с существующими сервисами (например, UsersService, ContactsService).  
    5. Реализовать защиту GraphQL эндпоинтов с использованием существующих guards (например, JwtAuthGuard, RolesGuard).  
  * **Ожидаемый результат:** Рабочий GraphQL API для выбранных сущностей.  
  * *Файлы: backend/src/graphql/\*\* (новая папка с модулем), обновления в существующих сервисах для поддержки GraphQL resolvers.*  
* \[ \] **Задача 6.1.3 (Если принято решение внедрять GraphQL): Интеграция GraphQL клиента на Frontend.**  
  * **Контекст:** Использование GraphQL API на клиенте (Дополнение к ТЗ для ИИ, Задача 5.3).  
  * **Тех. указания:**  
    1. Установить Apollo Client: npm install @apollo/client graphql.  
    2. Настроить ApolloProvider в Next.js.  
    3. Переписать несколько существующих компонентов или создать новые, которые будут использовать GraphQL запросы (queries/mutations) вместо REST API для получения/изменения данных (для тех сущностей, что были реализованы на бэкенде).  
  * **Ожидаемый результат:** Компоненты, использующие GraphQL.  
  * *Файлы: frontend/src/lib/apolloClient.ts (новый), обновления в существующих компонентах или новые компоненты.*  
* \[ \] **Задача 6.1.4 (Если принято решение внедрять GraphQL): Документирование GraphQL схемы.**  
  * **Контекст:** Предоставление информации о GraphQL API (Дополнение к ТЗ для ИИ, Задача 5.4).  
  * **Тех. указания:**  
    1. Убедиться, что GraphQL Playground (или аналогичный инструмент, например GraphiQL) доступен для исследования схемы в dev-режиме.  
    2. Добавить комментарии к типам, полям, запросам и мутациям в коде (code-first), чтобы они отображались в документации схемы.  
  * **Ожидаемый результат:** Доступная и самодокументируемая GraphQL схема.

### **Спринт 22: Оптимизация, Подготовка к расширению, Финальная документация (2-3 недели)**

**Цель спринта:** Улучшить производительность системы, подготовить проект к дальнейшему расширению и завершить всю необходимую документацию.

#### **Оптимизация**

* \[ \] **Задача 6.2.1: Профилирование производительности бэкенда и фронтенда, устранение узких мест.**  
  * **Контекст:** Поиск и исправление проблем производительности.  
  * **Тех. указания:**  
    1. **Backend:**  
       * Использовать инструменты NestJS для логирования времени выполнения запросов или специализированные APM-инструменты (если есть, например, Sentry APM).  
       * Проанализировать медленные эндпоинты.  
       * ИИ может предложить общие паттерны оптимизации для Node.js/NestJS приложений.  
    2. **Frontend:**  
       * Использовать Lighthouse, Chrome DevTools (Performance, Network tabs) для анализа производительности.  
       * Оптимизировать загрузку ресурсов, рендеринг компонентов (React.memo, useMemo, useCallback).  
       * Проверить Core Web Vitals.  
    3. Разработчик определяет узкие места, ИИ помогает с генерацией оптимизированного кода или предложений по рефакторингу.  
  * **Ожидаемый результат:** Улучшенная производительность ключевых частей системы. Список проведенных оптимизаций.  
* \[ \] **Задача 6.2.2: Оптимизация запросов к БД и Elasticsearch.**  
  * **Контекст:** Ускорение взаимодействия с хранилищами данных.  
  * **Тех. указания:**  
    1. **PostgreSQL (Prisma):**  
       * Проанализировать медленные запросы (использовать EXPLAIN ANALYZE).  
       * Проверить наличие необходимых индексов для часто используемых полей в фильтрах и сортировках. ИИ может помочь сгенерировать ALTER TABLE команды для добавления индексов или @index в Prisma schema.  
       * Оптимизировать логику Prisma-запросов (например, избегать N+1 проблем, использовать select для выбора только нужных полей).  
    2. **Elasticsearch:**  
       * Проанализировать медленные поисковые запросы.  
       * Оптимизировать маппинги и настройки индексов.  
  * **Ожидаемый результат:** Оптимизированные запросы к БД и Elasticsearch.  
  * *Файлы: backend/prisma/schema.prisma (для индексов), код сервисов с запросами.*

#### **Подготовка к расширению (ТЗ 4.7)**

* \[ \] **Задача 6.3.1: Финализация best practices и гайдлайнов по разработке.**  
  * **Контекст:** Формализация стандартов разработки для обеспечения консистентности и качества.  
  * **Тех. указания:**  
    1. Собрать все ранее определенные best practices (стиль кода, комментирование, тестирование, безопасность, работа с ИИ).  
    2. Дополнить их на основе опыта, полученного в ходе разработки.  
    3. Оформить в виде единого документа (например, CONTRIBUTING.md или страница в Wiki).  
  * **Ожидаемый результат:** Документ с best practices и гайдлайнами.  
* \[ \] **Задача 6.3.2: Подготовка инфраструктуры к возможному будущему масштабированию.**  
  * **Контекст:** Обзор текущих настроек и планирование масштабирования.  
  * **Тех. указания:** (Больше аналитическая задача для разработчика, ИИ может помочь с поиском информации)  
    1. Просмотреть конфигурацию Docker Compose и подготовить наброски для Dockerfile'ов, оптимизированных для production (multi-stage builds, non-root users).  
    2. Если планируется Kubernetes (ТЗ 3.1):  
       * Начать проектирование базовых Kubernetes-манифестов (Deployment, Service, Ingress) для frontend и backend.  
       * Исследовать варианты управления конфигурацией в Kubernetes (ConfigMaps, Secrets).  
    3. ИИ может сгенерировать примеры Dockerfile и базовых Kubernetes-манифестов.  
  * **Ожидаемый результат:** Оптимизированные Dockerfile (черновики), примеры Kubernetes-манифестов (черновики).

#### **Документация**

* \[ \] **Задача 6.4.1: Завершение всех руководств пользователя и технической документации.**  
  * **Контекст:** Финализация всей документации проекта (ТЗ 4.6).  
  * **Тех. указания:**  
    1. Проверить полноту и актуальность руководств пользователя (созданных в Задаче 5.2.4).  
    2. Проверить полноту технической документации (архитектура, API, документация по компонентам).  
    3. Добавить раздел "Установка и настройка" для локального развертывания и, если есть, для production.  
    4. Добавить раздел "Устранение неполадок" (FAQ).  
  * **Ожидаемый результат:** Полный комплект пользовательской и технической документации.  
* \[ \] **Задача 6.4.2: Создание обучающих материалов (базовых).**  
  * **Контекст:** Подготовка материалов для обучения пользователей (ТЗ 4.6).  
  * **Тех. указания:**  
    1. На основе руководств пользователя создать несколько коротких обучающих сценариев или видео-скриптов (ИИ может помочь со структурой и текстом скриптов).  
    2. Например: "Как зарегистрироваться и настроить профиль", "Как создать и провести сделку", "Как пользоваться аналитикой".  
  * **Ожидаемый результат:** Структура и тексты для базовых обучающих материалов.

## **Этап 7: Бета-Тестирование и Доработка (4-6 недель)**

**Цель этапа:** Провести тестирование системы на реальных пользователях, собрать обратную связь и доработать продукт перед релизом. На этом этапе роль ИИ в основном вспомогательная: анализ обратной связи, помощь в отладке, генерация кода для исправлений.

### **Спринты 23-24 (или более, по необходимости)**

* \[ \] **Задача 7.1.1: Развертывание бета-версии на выделенном стенде.**  
  * **Контекст:** Подготовка окружения для бета-тестирования. 
  * **Тех. указания:**  
    1. Подготовить скрипты для развертывания (например, используя Docker Compose на отдельном сервере или базовые Kubernetes-манифесты).  
    2. Настроить CI/CD для автоматического обновления бета-стенда из определенной ветки.  
  * **Ожидаемый результат:** Развернутая бета-версия.  
* \[ \] **Задача 7.1.2: Активный сбор и анализ обратной связи.**  
  * **Контекст:** Получение фидбека от реальных пользователей.  
  * **Тех. указания:** (Разработчик организует сбор, ИИ может помочь в обработке)  
    1. Настроить систему для сбора обратной связи (например, Google Forms, специализированный сервис, или задачи в трекере).  
    2. ИИ может помочь в:  
       * Классификации обратной связи (баги, предложения по улучшению, вопросы).  
       * Анализе тональности отзывов.  
       * Группировке схожих сообщений.  
  * **Ожидаемый результат:** Систематизированная обратная связь от пользователей.  
* \[ \] **Задача 7.1.3: Итеративная доработка: исправление выявленных ошибок, улучшение UI/UX.**  
  * **Контекст:** Улучшение продукта на основе фидбека.  
  * **Тех. указания:**  
    1. Разработчик ставит конкретные задачи ИИ по исправлению багов или реализации небольших улучшений.  
    2. Пример задачи для ИИ: "В компоненте X (файл Y.tsx) при таких-то условиях возникает ошибка Z. Проанализируй код и предложи исправление."  
    3. Пример задачи для ИИ: "Пользователи сообщают, что кнопка A на странице B не очевидна. Предложи 2-3 варианта улучшения ее дизайна или расположения."  
    4. Требовать от ИИ генерации кода с тестами для исправлений.  
  * **Ожидаемый результат:** Исправленные баги, улучшенный UI/UX.  
* \[ \] **Задача 7.1.4: Приоритизация доработок для релиза.**  
  * **Контекст:** Определение наиболее важных изменений перед релизом. (Задача для разработчика/Product Owner).  
  * **Ожидаемый результат:** Утвержденный список доработок для релиза.

## **Этап 8: Релиз и Начальная Поддержка (2-4 недели \+ постоянно)**

**Цель этапа:** Выпустить продукт в промышленную эксплуатацию, обеспечить его стабильную работу и начать процесс постоянной поддержки и развития.

### **Спринт \~25 (или по готовности)**

* \[ \] **Задача 8.1.1: Подготовка к релизу: финальное тестирование, подготовка миграций данных, создание релизных сборок.**  
  * **Контекст:** Завершающие шаги перед запуском.  
  * **Тех. указания:**  
    1. **Финальное тестирование:** Провести полный цикл регрессионного тестирования. 
    2. **Миграции данных:** Если для продакшн-среды требуются специфические миграции данных (отличные от dev/beta), подготовить и протестировать их. 
    3. **Релизные сборки:** Настроить CI/CD для создания production-сборок (оптимизированных, сжатых, без dev-инструментов).  
  * **Ожидаемый результат:** Протестированная система, готовые миграции, настроенный CI/CD для релиза.  
* \[ \] **Задача 8.1.2: Развертывание продакшн-версии на основной инфраструктуре.**  
  * **Контекст:** Запуск системы в промышленную эксплуатацию. 
  * **Тех. указания:**  
    1. Использовать подготовленные скрипты/манифесты для развертывания.  
    2. Провести развертывание в период наименьшей нагрузки.  
    3. Иметь план отката на случай проблем.  
  * **Ожидаемый результат:** Развернутая продакшн-версия системы.  
* \[ \] **Задача 8.1.3: Мониторинг запуска.**  
  * **Контекст:** Активное наблюдение за системой в первые дни/недели после релиза.  
  * **Тех. указания:**  
    1. Следить за логами, метриками производительности (Sentry, Prometheus, Grafana).  
    2. Быстро реагировать на возникающие проблемы.  
    3. ИИ может помочь в анализе логов или поиске информации по кодам ошибок.  
  * **Ожидаемый результат:** Стабильная работа системы после запуска.  
* \[ \] **Задача 8.1.4: Обучение пользователей (если еще не проводилось или требуются дополнительные сессии).**  
  * **Контекст:** Помощь пользователям в освоении системы. (Задача для разработчика/специалиста по обучению).  
  * **Тех. указания:** Использовать ранее созданные обучающие материалы (Задача 6.4.2).  
  * **Ожидаемый результат:** Обученные пользователи.  
* \[ \] **Задача 8.1.5: Запуск в эксплуатацию.**  
  * **Контекст:** Официальное объявление о запуске системы.  
  * **Ожидаемый результат:** Система в промышленной эксплуатации.

#### **Постоянная поддержка и развитие (после релиза)**

* \[ \] **Задача 8.2.1: Техническая поддержка: реагирование на инциденты, исправление ошибок.**  
  * **Контекст:** Обеспечение бесперебойной работы системы.  
  * **Тех. указания:** ИИ может использоваться для:  
    * Помощи в диагностике проблем на основе логов и описаний от пользователей.  
    * Генерации кода для исправлений (с тестами).  
    * Поиска решений для известных проблем в библиотеках/фреймворках.  
* \[ \] **Задача 8.2.2: Развитие функциональности: сбор требований, планирование и реализация новых версий и компонентов.**  
  * **Контекст:** Непрерывное улучшение продукта.  
  * **Тех. указания:** ИИ может помогать на всех этапах:  
    * Анализ запросов на новую функциональность.  
    * Проектирование новых фич.  
    * Генерация кода для новых модулей/компонентов.  
    * Написание тестов и документации.  
* \[ \] **Задача 8.2.3: Оптимизация и масштабирование по мере роста нагрузки и потребностей.**  
  * **Контекст:** Адаптация системы к изменяющимся условиям.  
  * **Тех. указания:** ИИ может помочь:  
    * В анализе узких мест производительности при росте нагрузки.  
    * В предложении стратегий масштабирования (вертикальное/горизонтальное).  
    * В генерации обновленных конфигураций для инфраструктуры.